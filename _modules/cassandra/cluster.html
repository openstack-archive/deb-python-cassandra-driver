<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cassandra.cluster &#8212; Cassandra Driver 3.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '3.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Cassandra Driver 3.11.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../cassandra.html" accesskey="U">cassandra</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cassandra.cluster</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2013-2017 DataStax, Inc.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module houses the main classes you will interact with,</span>
<span class="sd">:class:`.Cluster` and :class:`.Session`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">atexit</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="k">import</span> <span class="n">ThreadPoolExecutor</span><span class="p">,</span> <span class="n">FIRST_COMPLETED</span><span class="p">,</span> <span class="n">wait</span> <span class="k">as</span> <span class="n">wait_futures</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">count</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">random</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">queue</span> <span class="k">as</span> <span class="n">Queue</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="k">import</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">RLock</span><span class="p">,</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Event</span>

<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="k">import</span> <span class="n">WeakValueDictionary</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">weakref</span> <span class="k">import</span> <span class="n">WeakSet</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">cassandra.util</span> <span class="k">import</span> <span class="n">WeakSet</span>  <span class="c1"># NOQA</span>

<span class="kn">from</span> <span class="nn">cassandra</span> <span class="k">import</span> <span class="p">(</span><span class="n">ConsistencyLevel</span><span class="p">,</span> <span class="n">AuthenticationFailed</span><span class="p">,</span>
                       <span class="n">OperationTimedOut</span><span class="p">,</span> <span class="n">UnsupportedOperation</span><span class="p">,</span>
                       <span class="n">SchemaTargetType</span><span class="p">,</span> <span class="n">DriverException</span><span class="p">,</span> <span class="n">ProtocolVersion</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">cassandra.connection</span> <span class="k">import</span> <span class="p">(</span><span class="n">ConnectionException</span><span class="p">,</span> <span class="n">ConnectionShutdown</span><span class="p">,</span>
                                  <span class="n">ConnectionHeartbeat</span><span class="p">,</span> <span class="n">ProtocolVersionUnsupported</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">cassandra.cqltypes</span> <span class="k">import</span> <span class="n">UserType</span>
<span class="kn">from</span> <span class="nn">cassandra.encoder</span> <span class="k">import</span> <span class="n">Encoder</span>
<span class="kn">from</span> <span class="nn">cassandra.protocol</span> <span class="k">import</span> <span class="p">(</span><span class="n">QueryMessage</span><span class="p">,</span> <span class="n">ResultMessage</span><span class="p">,</span>
                                <span class="n">ErrorMessage</span><span class="p">,</span> <span class="n">ReadTimeoutErrorMessage</span><span class="p">,</span>
                                <span class="n">WriteTimeoutErrorMessage</span><span class="p">,</span>
                                <span class="n">UnavailableErrorMessage</span><span class="p">,</span>
                                <span class="n">OverloadedErrorMessage</span><span class="p">,</span>
                                <span class="n">PrepareMessage</span><span class="p">,</span> <span class="n">ExecuteMessage</span><span class="p">,</span>
                                <span class="n">PreparedQueryNotFound</span><span class="p">,</span>
                                <span class="n">IsBootstrappingErrorMessage</span><span class="p">,</span>
                                <span class="n">BatchMessage</span><span class="p">,</span> <span class="n">RESULT_KIND_PREPARED</span><span class="p">,</span>
                                <span class="n">RESULT_KIND_SET_KEYSPACE</span><span class="p">,</span> <span class="n">RESULT_KIND_ROWS</span><span class="p">,</span>
                                <span class="n">RESULT_KIND_SCHEMA_CHANGE</span><span class="p">,</span> <span class="n">ProtocolHandler</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">cassandra.metadata</span> <span class="k">import</span> <span class="n">Metadata</span><span class="p">,</span> <span class="n">protect_name</span><span class="p">,</span> <span class="n">murmur3</span>
<span class="kn">from</span> <span class="nn">cassandra.policies</span> <span class="k">import</span> <span class="p">(</span><span class="n">TokenAwarePolicy</span><span class="p">,</span> <span class="n">DCAwareRoundRobinPolicy</span><span class="p">,</span> <span class="n">SimpleConvictionPolicy</span><span class="p">,</span>
                                <span class="n">ExponentialReconnectionPolicy</span><span class="p">,</span> <span class="n">HostDistance</span><span class="p">,</span>
                                <span class="n">RetryPolicy</span><span class="p">,</span> <span class="n">IdentityTranslator</span><span class="p">,</span> <span class="n">NoSpeculativeExecutionPlan</span><span class="p">,</span>
                                <span class="n">NoSpeculativeExecutionPolicy</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">cassandra.pool</span> <span class="k">import</span> <span class="p">(</span><span class="n">Host</span><span class="p">,</span> <span class="n">_ReconnectionHandler</span><span class="p">,</span> <span class="n">_HostReconnectionHandler</span><span class="p">,</span>
                            <span class="n">HostConnectionPool</span><span class="p">,</span> <span class="n">HostConnection</span><span class="p">,</span>
                            <span class="n">NoConnectionsAvailable</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">cassandra.query</span> <span class="k">import</span> <span class="p">(</span><span class="n">SimpleStatement</span><span class="p">,</span> <span class="n">PreparedStatement</span><span class="p">,</span> <span class="n">BoundStatement</span><span class="p">,</span>
                             <span class="n">BatchStatement</span><span class="p">,</span> <span class="n">bind_params</span><span class="p">,</span> <span class="n">QueryTrace</span><span class="p">,</span> <span class="n">TraceUnavailable</span><span class="p">,</span>
                             <span class="n">named_tuple_factory</span><span class="p">,</span> <span class="n">dict_factory</span><span class="p">,</span> <span class="n">tuple_factory</span><span class="p">,</span> <span class="n">FETCH_SIZE_UNSET</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">cassandra.timestamps</span> <span class="k">import</span> <span class="n">MonotonicTimestampGenerator</span>


<span class="k">def</span> <span class="nf">_is_eventlet_monkey_patched</span><span class="p">():</span>
    <span class="k">if</span> <span class="s1">&#39;eventlet.patcher&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="kn">import</span> <span class="nn">eventlet.patcher</span>
    <span class="k">return</span> <span class="n">eventlet</span><span class="o">.</span><span class="n">patcher</span><span class="o">.</span><span class="n">is_monkey_patched</span><span class="p">(</span><span class="s1">&#39;socket&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_gevent_monkey_patched</span><span class="p">():</span>
    <span class="k">if</span> <span class="s1">&#39;gevent.monkey&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="kn">import</span> <span class="nn">gevent.socket</span>
    <span class="k">return</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span> <span class="ow">is</span> <span class="n">gevent</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span>

<span class="c1"># default to gevent when we are monkey patched with gevent, eventlet when</span>
<span class="c1"># monkey patched with eventlet, otherwise if libev is available, use that as</span>
<span class="c1"># the default because it&#39;s fastest. Otherwise, use asyncore.</span>
<span class="k">if</span> <span class="n">_is_gevent_monkey_patched</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">cassandra.io.geventreactor</span> <span class="k">import</span> <span class="n">GeventConnection</span> <span class="k">as</span> <span class="n">DefaultConnection</span>
<span class="k">elif</span> <span class="n">_is_eventlet_monkey_patched</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">cassandra.io.eventletreactor</span> <span class="k">import</span> <span class="n">EventletConnection</span> <span class="k">as</span> <span class="n">DefaultConnection</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">cassandra.io.libevreactor</span> <span class="k">import</span> <span class="n">LibevConnection</span> <span class="k">as</span> <span class="n">DefaultConnection</span>  <span class="c1"># NOQA</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">cassandra.io.asyncorereactor</span> <span class="k">import</span> <span class="n">AsyncoreConnection</span> <span class="k">as</span> <span class="n">DefaultConnection</span>  <span class="c1"># NOQA</span>

<span class="c1"># Forces load of utf8 encoding module to avoid deadlock that occurs</span>
<span class="c1"># if code that is being imported tries to import the module in a seperate</span>
<span class="c1"># thread.</span>
<span class="c1"># See http://bugs.python.org/issue10923</span>
<span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="n">DEFAULT_MIN_REQUESTS</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">DEFAULT_MAX_REQUESTS</span> <span class="o">=</span> <span class="mi">100</span>

<span class="n">DEFAULT_MIN_CONNECTIONS_PER_LOCAL_HOST</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">DEFAULT_MAX_CONNECTIONS_PER_LOCAL_HOST</span> <span class="o">=</span> <span class="mi">8</span>

<span class="n">DEFAULT_MIN_CONNECTIONS_PER_REMOTE_HOST</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">DEFAULT_MAX_CONNECTIONS_PER_REMOTE_HOST</span> <span class="o">=</span> <span class="mi">2</span>


<span class="n">_NOT_SET</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<div class="viewcode-block" id="NoHostAvailable"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.NoHostAvailable">[docs]</a><span class="k">class</span> <span class="nc">NoHostAvailable</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raised when an operation is attempted but all connections are</span>
<span class="sd">    busy, defunct, closed, or resulted in errors when used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">errors</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A map of the form ``{ip: exception}`` which details the particular</span>
<span class="sd">    Exception that was caught for each host the operation was attempted</span>
<span class="sd">    against.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">errors</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="n">errors</span></div>


<span class="k">def</span> <span class="nf">_future_completed</span><span class="p">(</span><span class="n">future</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Helper for run_in_executor() &quot;&quot;&quot;</span>
    <span class="n">exc</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Failed to run task on executor&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">run_in_executor</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A decorator to run the given method in the ThreadPoolExecutor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">new_f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">_future_completed</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Failed to submit task to executor&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_f</span>


<span class="n">_clusters_for_shutdown</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_register_cluster_shutdown</span><span class="p">(</span><span class="n">cluster</span><span class="p">):</span>
    <span class="n">_clusters_for_shutdown</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_discard_cluster_shutdown</span><span class="p">(</span><span class="n">cluster</span><span class="p">):</span>
    <span class="n">_clusters_for_shutdown</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_shutdown_clusters</span><span class="p">():</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="n">_clusters_for_shutdown</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># copy because shutdown modifies the global set &quot;discard&quot;</span>
    <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
        <span class="n">cluster</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

<span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">_shutdown_clusters</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">default_lbp_factory</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">murmur3</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TokenAwarePolicy</span><span class="p">(</span><span class="n">DCAwareRoundRobinPolicy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">DCAwareRoundRobinPolicy</span><span class="p">()</span>


<div class="viewcode-block" id="ExecutionProfile"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ExecutionProfile">[docs]</a><span class="k">class</span> <span class="nc">ExecutionProfile</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">load_balancing_policy</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An instance of :class:`.policies.LoadBalancingPolicy` or one of its subclasses.</span>

<span class="sd">    Used in determining host distance for establishing connections, and routing requests.</span>

<span class="sd">    Defaults to ``TokenAwarePolicy(DCAwareRoundRobinPolicy())`` if not specified</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">retry_policy</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An instance of :class:`.policies.RetryPolicy` instance used when :class:`.Statement` objects do not have a</span>
<span class="sd">    :attr:`~.Statement.retry_policy` explicitly set.</span>

<span class="sd">    Defaults to :class:`.RetryPolicy` if not specified</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">consistency_level</span> <span class="o">=</span> <span class="n">ConsistencyLevel</span><span class="o">.</span><span class="n">LOCAL_ONE</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :class:`.ConsistencyLevel` used when not specified on a :class:`.Statement`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">serial_consistency_level</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Serial :class:`.ConsistencyLevel` used when not specified on a :class:`.Statement` (for LWT conditional statements).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">request_timeout</span> <span class="o">=</span> <span class="mf">10.0</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Request timeout used when not overridden in :meth:`.Session.execute`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">row_factory</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">tuple_factory</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A callable to format results, accepting ``(colnames, rows)`` where ``colnames`` is a list of column names, and</span>
<span class="sd">    ``rows`` is a list of tuples, with each tuple representing a row of parsed values.</span>

<span class="sd">    Some example implementations:</span>

<span class="sd">        - :func:`cassandra.query.tuple_factory` - return a result row as a tuple</span>
<span class="sd">        - :func:`cassandra.query.named_tuple_factory` - return a result row as a named tuple</span>
<span class="sd">        - :func:`cassandra.query.dict_factory` - return a result row as a dict</span>
<span class="sd">        - :func:`cassandra.query.ordered_dict_factory` - return a result row as an OrderedDict</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">speculative_execution_policy</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An instance of :class:`.policies.SpeculativeExecutionPolicy`</span>

<span class="sd">    Defaults to :class:`.NoSpeculativeExecutionPolicy` if not specified</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">load_balancing_policy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retry_policy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">consistency_level</span><span class="o">=</span><span class="n">ConsistencyLevel</span><span class="o">.</span><span class="n">LOCAL_ONE</span><span class="p">,</span> <span class="n">serial_consistency_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">request_timeout</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">row_factory</span><span class="o">=</span><span class="n">named_tuple_factory</span><span class="p">,</span> <span class="n">speculative_execution_policy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_balancing_policy</span> <span class="o">=</span> <span class="n">load_balancing_policy</span> <span class="ow">or</span> <span class="n">default_lbp_factory</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retry_policy</span> <span class="o">=</span> <span class="n">retry_policy</span> <span class="ow">or</span> <span class="n">RetryPolicy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consistency_level</span> <span class="o">=</span> <span class="n">consistency_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serial_consistency_level</span> <span class="o">=</span> <span class="n">serial_consistency_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request_timeout</span> <span class="o">=</span> <span class="n">request_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">row_factory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speculative_execution_policy</span> <span class="o">=</span> <span class="n">speculative_execution_policy</span> <span class="ow">or</span> <span class="n">NoSpeculativeExecutionPolicy</span><span class="p">()</span></div>


<span class="k">class</span> <span class="nc">ProfileManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">LOCAL</span> <span class="k">if</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">LOCAL</span> <span class="ow">in</span> <span class="n">distances</span> <span class="k">else</span> \
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">REMOTE</span> <span class="k">if</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">REMOTE</span> <span class="ow">in</span> <span class="n">distances</span> <span class="k">else</span> \
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span>

    <span class="k">def</span> <span class="nf">populate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">hosts</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">hosts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_supported</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="o">.</span><span class="n">check_supported</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="o">.</span><span class="n">on_up</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="o">.</span><span class="n">on_add</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="o">.</span><span class="n">on_remove</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        internal-only; no checks are done because this entry is populated on cluster init</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">[</span><span class="n">EXEC_PROFILE_DEFAULT</span><span class="p">]</span>


<span class="n">EXEC_PROFILE_DEFAULT</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Key for the ``Cluster`` default execution profile, used when no other profile is selected in</span>
<span class="sd">``Session.execute(execution_profile)``.</span>

<span class="sd">Use this as the key in ``Cluster(execution_profiles)`` to override the default profile.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">_ConfigMode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">UNCOMMITTED</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">LEGACY</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">PROFILES</span> <span class="o">=</span> <span class="mi">2</span>


<div class="viewcode-block" id="Cluster"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster">[docs]</a><span class="k">class</span> <span class="nc">Cluster</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The main class to use when interacting with a Cassandra cluster.</span>
<span class="sd">    Typically, one instance of this class will be created for each</span>
<span class="sd">    separate Cassandra cluster that your application interacts with.</span>

<span class="sd">    Example usage::</span>

<span class="sd">        &gt;&gt;&gt; from cassandra.cluster import Cluster</span>
<span class="sd">        &gt;&gt;&gt; cluster = Cluster([&#39;192.168.1.1&#39;, &#39;192.168.1.2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; session = cluster.connect()</span>
<span class="sd">        &gt;&gt;&gt; session.execute(&quot;CREATE KEYSPACE ...&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ...</span>
<span class="sd">        &gt;&gt;&gt; cluster.shutdown()</span>

<span class="sd">    ``Cluster`` and ``Session`` also provide context management functions</span>
<span class="sd">    which implicitly handle shutdown when leaving scope.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">contact_points</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The list of contact points to try connecting for cluster discovery.</span>

<span class="sd">    Defaults to loopback interface.</span>

<span class="sd">    Note: When using :class:`.DCAwareLoadBalancingPolicy` with no explicit</span>
<span class="sd">    local_dc set (as is the default), the DC is chosen from an arbitrary</span>
<span class="sd">    host in contact_points. In this case, contact_points should contain</span>
<span class="sd">    only nodes from a single, local DC.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">port</span> <span class="o">=</span> <span class="mi">9042</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The server-side port to open connections to. Defaults to 9042.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cql_version</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If a specific version of CQL should be used, this may be set to that</span>
<span class="sd">    string version.  Otherwise, the highest CQL version supported by the</span>
<span class="sd">    server will be automatically used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">protocol_version</span> <span class="o">=</span> <span class="n">ProtocolVersion</span><span class="o">.</span><span class="n">V4</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum version of the native protocol to use.</span>

<span class="sd">    See :class:`.ProtocolVersion` for more information about versions.</span>

<span class="sd">    If not set in the constructor, the driver will automatically downgrade</span>
<span class="sd">    version based on a negotiation with the server, but it is most efficient</span>
<span class="sd">    to set this to the maximum supported by your version of Cassandra.</span>
<span class="sd">    Setting this will also prevent conflicting versions negotiated if your</span>
<span class="sd">    cluster is upgraded.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">allow_beta_protocol_version</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setting true injects a flag in all messages that makes the server accept and use &quot;beta&quot; protocol version.</span>
<span class="sd">    Used for testing new protocol features incrementally before the new version is complete.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">compression</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Controls compression for communications between the driver and Cassandra.</span>
<span class="sd">    If left as the default of :const:`True`, either lz4 or snappy compression</span>
<span class="sd">    may be used, depending on what is supported by both the driver</span>
<span class="sd">    and Cassandra.  If both are fully supported, lz4 will be preferred.</span>

<span class="sd">    You may also set this to &#39;snappy&#39; or &#39;lz4&#39; to request that specific</span>
<span class="sd">    compression type.</span>

<span class="sd">    Setting this to :const:`False` disables compression.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_auth_provider</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_auth_provider_callable</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">auth_provider</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When :attr:`~.Cluster.protocol_version` is 2 or higher, this should</span>
<span class="sd">        be an instance of a subclass of :class:`~cassandra.auth.AuthProvider`,</span>
<span class="sd">        such as :class:`~.PlainTextAuthProvider`.</span>

<span class="sd">        When :attr:`~.Cluster.protocol_version` is 1, this should be</span>
<span class="sd">        a function that accepts one argument, the IP address of a node,</span>
<span class="sd">        and returns a dict of credentials for that node.</span>

<span class="sd">        When not using authentication, this should be left as :const:`None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auth_provider</span>

    <span class="nd">@auth_provider</span><span class="o">.</span><span class="n">setter</span>  <span class="c1"># noqa</span>
    <span class="k">def</span> <span class="nf">auth_provider</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auth_provider</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auth_provider_callable</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">new_authenticator</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;auth_provider must implement the cassandra.auth.AuthProvider &quot;</span>
                                <span class="s2">&quot;interface when protocol_version &gt;= 2&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;auth_provider must be callable when protocol_version == 1&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auth_provider_callable</span> <span class="o">=</span> <span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_auth_provider</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">_load_balancing_policy</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">load_balancing_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An instance of :class:`.policies.LoadBalancingPolicy` or</span>
<span class="sd">        one of its subclasses.</span>

<span class="sd">        .. versionchanged:: 2.6.0</span>

<span class="sd">        Defaults to :class:`~.TokenAwarePolicy` (:class:`~.DCAwareRoundRobinPolicy`).</span>
<span class="sd">        when using CPython (where the murmur3 extension is available). :class:`~.DCAwareRoundRobinPolicy`</span>
<span class="sd">        otherwise. Default local DC will be chosen from contact points.</span>

<span class="sd">        **Please see** :class:`~.DCAwareRoundRobinPolicy` **for a discussion on default behavior with respect to</span>
<span class="sd">        DC locality and remote nodes.**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_balancing_policy</span>

    <span class="nd">@load_balancing_policy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">load_balancing_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lbp</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">==</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">PROFILES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set Cluster.load_balancing_policy while using Configuration Profiles. Set this in a profile instead.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_balancing_policy</span> <span class="o">=</span> <span class="n">lbp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">=</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">LEGACY</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_default_load_balancing_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">load_balancing_policy</span>

    <span class="n">reconnection_policy</span> <span class="o">=</span> <span class="n">ExponentialReconnectionPolicy</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">600.0</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An instance of :class:`.policies.ReconnectionPolicy`. Defaults to an instance</span>
<span class="sd">    of :class:`.ExponentialReconnectionPolicy` with a base delay of one second and</span>
<span class="sd">    a max delay of ten minutes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_default_retry_policy</span> <span class="o">=</span> <span class="n">RetryPolicy</span><span class="p">()</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_retry_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A default :class:`.policies.RetryPolicy` instance to use for all</span>
<span class="sd">        :class:`.Statement` objects which do not have a :attr:`~.Statement.retry_policy`</span>
<span class="sd">        explicitly set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_retry_policy</span>

    <span class="nd">@default_retry_policy</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">default_retry_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">==</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">PROFILES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set Cluster.default_retry_policy while using Configuration Profiles. Set this in a profile instead.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_retry_policy</span> <span class="o">=</span> <span class="n">policy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">=</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">LEGACY</span>

    <span class="n">conviction_policy_factory</span> <span class="o">=</span> <span class="n">SimpleConvictionPolicy</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A factory function which creates instances of</span>
<span class="sd">    :class:`.policies.ConvictionPolicy`.  Defaults to</span>
<span class="sd">    :class:`.policies.SimpleConvictionPolicy`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">address_translator</span> <span class="o">=</span> <span class="n">IdentityTranslator</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :class:`.policies.AddressTranslator` instance to be used in translating server node addresses</span>
<span class="sd">    to driver connection addresses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">connect_to_remote_hosts</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If left as :const:`True`, hosts that are considered :attr:`~.HostDistance.REMOTE`</span>
<span class="sd">    by the :attr:`~.Cluster.load_balancing_policy` will have a connection</span>
<span class="sd">    opened to them.  Otherwise, they will not have a connection opened to them.</span>

<span class="sd">    Note that the default load balancing policy ignores remote hosts by default.</span>

<span class="sd">    .. versionadded:: 2.1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metrics_enabled</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Whether or not metric collection is enabled.  If enabled, :attr:`.metrics`</span>
<span class="sd">    will be an instance of :class:`~cassandra.metrics.Metrics`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metrics</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An instance of :class:`cassandra.metrics.Metrics` if :attr:`.metrics_enabled` is</span>
<span class="sd">    :const:`True`, else :const:`None`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ssl_options</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A optional dict which will be used as kwargs for ``ssl.wrap_socket()``</span>
<span class="sd">    when new sockets are created.  This should be used when client encryption</span>
<span class="sd">    is enabled in Cassandra.</span>

<span class="sd">    By default, a ``ca_certs`` value should be supplied (the value should be</span>
<span class="sd">    a string pointing to the location of the CA certs file), and you probably</span>
<span class="sd">    want to specify ``ssl_version`` as ``ssl.PROTOCOL_TLSv1`` to match</span>
<span class="sd">    Cassandra&#39;s default protocol.</span>

<span class="sd">    .. versionchanged:: 3.3.0</span>

<span class="sd">    In addition to ``wrap_socket`` kwargs, clients may also specify ``&#39;check_hostname&#39;: True`` to verify the cert hostname</span>
<span class="sd">    as outlined in RFC 2818 and RFC 6125. Note that this requires the certificate to be transferred, so</span>
<span class="sd">    should almost always require the option ``&#39;cert_reqs&#39;: ssl.CERT_REQUIRED``. Note also that this functionality was not built into</span>
<span class="sd">    Python standard library until (2.7.9, 3.2). To enable this mechanism in earlier versions, patch ``ssl.match_hostname``</span>
<span class="sd">    with a custom or `back-ported function &lt;https://pypi.python.org/pypi/backports.ssl_match_hostname&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sockopts</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An optional list of tuples which will be used as arguments to</span>
<span class="sd">    ``socket.setsockopt()`` for all created sockets.</span>

<span class="sd">    Note: some drivers find setting TCPNODELAY beneficial in the context of</span>
<span class="sd">    their execution model. It was not found generally beneficial for this driver.</span>
<span class="sd">    To try with your own workload, set ``sockopts = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">max_schema_agreement_wait</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum duration (in seconds) that the driver will wait for schema</span>
<span class="sd">    agreement across the cluster. Defaults to ten seconds.</span>
<span class="sd">    If set &lt;= 0, the driver will bypass schema agreement waits altogether.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metadata</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An instance of :class:`cassandra.metadata.Metadata`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">connection_class</span> <span class="o">=</span> <span class="n">DefaultConnection</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This determines what event loop system will be used for managing</span>
<span class="sd">    I/O with Cassandra.  These are the current options:</span>

<span class="sd">    * :class:`cassandra.io.asyncorereactor.AsyncoreConnection`</span>
<span class="sd">    * :class:`cassandra.io.libevreactor.LibevConnection`</span>
<span class="sd">    * :class:`cassandra.io.eventletreactor.EventletConnection` (requires monkey-patching - see doc for details)</span>
<span class="sd">    * :class:`cassandra.io.geventreactor.GeventConnection` (requires monkey-patching - see doc for details)</span>
<span class="sd">    * :class:`cassandra.io.twistedreactor.TwistedConnection`</span>

<span class="sd">    By default, ``AsyncoreConnection`` will be used, which uses</span>
<span class="sd">    the ``asyncore`` module in the Python standard library.</span>

<span class="sd">    If ``libev`` is installed, ``LibevConnection`` will be used instead.</span>

<span class="sd">    If ``gevent`` or ``eventlet`` monkey-patching is detected, the corresponding</span>
<span class="sd">    connection class will be used automatically.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">control_connection_timeout</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A timeout, in seconds, for queries made by the control connection, such</span>
<span class="sd">    as querying the current schema and information about nodes in the cluster.</span>
<span class="sd">    If set to :const:`None`, there will be no timeout for these queries.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">idle_heartbeat_interval</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interval, in seconds, on which to heartbeat idle connections. This helps</span>
<span class="sd">    keep connections open through network devices that expire idle connections.</span>
<span class="sd">    It also helps discover bad connections early in low-traffic scenarios.</span>
<span class="sd">    Setting to zero disables heartbeats.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">idle_heartbeat_timeout</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Timeout, in seconds, on which the heartbeat wait for idle connection responses.</span>
<span class="sd">    Lowering this value can help to discover bad connections earlier.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">schema_event_refresh_window</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Window, in seconds, within which a schema component will be refreshed after</span>
<span class="sd">    receiving a schema_change event.</span>

<span class="sd">    The driver delays a random amount of time in the range [0.0, window)</span>
<span class="sd">    before executing the refresh. This serves two purposes:</span>

<span class="sd">    1.) Spread the refresh for deployments with large fanout from C* to client tier,</span>
<span class="sd">    preventing a &#39;thundering herd&#39; problem with many clients refreshing simultaneously.</span>

<span class="sd">    2.) Remove redundant refreshes. Redundant events arriving within the delay period</span>
<span class="sd">    are discarded, and only one refresh is executed.</span>

<span class="sd">    Setting this to zero will execute refreshes immediately.</span>

<span class="sd">    Setting this negative will disable schema refreshes in response to push events</span>
<span class="sd">    (refreshes will still occur in response to schema change responses to DDL statements</span>
<span class="sd">    executed by Sessions of this Cluster).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">topology_event_refresh_window</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Window, in seconds, within which the node and token list will be refreshed after</span>
<span class="sd">    receiving a topology_change event.</span>

<span class="sd">    Setting this to zero will execute refreshes immediately.</span>

<span class="sd">    Setting this negative will disable node refreshes in response to push events.</span>

<span class="sd">    See :attr:`.schema_event_refresh_window` for discussion of rationale</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">status_event_refresh_window</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Window, in seconds, within which the driver will start the reconnect after</span>
<span class="sd">    receiving a status_change event.</span>

<span class="sd">    Setting this to zero will connect immediately.</span>

<span class="sd">    This is primarily used to avoid &#39;thundering herd&#39; in deployments with large fanout from cluster to clients.</span>
<span class="sd">    When nodes come up, clients attempt to reprepare prepared statements (depending on :attr:`.reprepare_on_up`), and</span>
<span class="sd">    establish connection pools. This can cause a rush of connections and queries if not mitigated with this factor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prepare_on_all_hosts</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specifies whether statements should be prepared on all hosts, or just one.</span>

<span class="sd">    This can reasonably be disabled on long-running applications with numerous clients preparing statements on startup,</span>
<span class="sd">    where a randomized initial condition of the load balancing policy can be expected to distribute prepares from</span>
<span class="sd">    different clients across the cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">reprepare_on_up</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specifies whether all known prepared statements should be prepared on a node when it comes up.</span>

<span class="sd">    May be used to avoid overwhelming a node on return, or if it is supposed that the node was only marked down due to</span>
<span class="sd">    network. If statements are not reprepared, they are prepared on the first execution, causing</span>
<span class="sd">    an extra roundtrip for one or more client requests.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">connect_timeout</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Timeout, in seconds, for creating new connections.</span>

<span class="sd">    This timeout covers the entire connection negotiation, including TCP</span>
<span class="sd">    establishment, options passing, and authentication.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">timestamp_generator</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object, shared between all sessions created by this cluster instance,</span>
<span class="sd">    that generates timestamps when client-side timestamp generation is enabled.</span>
<span class="sd">    By default, each :class:`Cluster` uses a new</span>
<span class="sd">    :class:`~.MonotonicTimestampGenerator`.</span>

<span class="sd">    Applications can set this value for custom timestamp behavior. See the</span>
<span class="sd">    documentation for :meth:`Session.timestamp_generator`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">schema_metadata_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flag indicating whether internal schema metadata is updated.</span>

<span class="sd">        When disabled, the driver does not populate Cluster.metadata.keyspaces on connect, or on schema change events. This</span>
<span class="sd">        can be used to speed initial connection, and reduce load on client and server during operation. Turning this off</span>
<span class="sd">        gives away token aware request routing, and programmatic inspection of the metadata model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">_schema_meta_enabled</span>

    <span class="nd">@schema_metadata_enabled</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">schema_metadata_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enabled</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">_schema_meta_enabled</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">enabled</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">token_metadata_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flag indicating whether internal token metadata is updated.</span>

<span class="sd">        When disabled, the driver does not query node token information on connect, or on topology change events. This</span>
<span class="sd">        can be used to speed initial connection, and reduce load on client and server during operation. It is most useful</span>
<span class="sd">        in large clusters using vnodes, where the token map can be expensive to compute. Turning this off</span>
<span class="sd">        gives away token aware request routing, and programmatic inspection of the token ring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">_token_meta_enabled</span>

    <span class="nd">@token_metadata_enabled</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">token_metadata_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enabled</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">_token_meta_enabled</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">enabled</span><span class="p">)</span>

    <span class="n">profile_manager</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_config_mode</span> <span class="o">=</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">UNCOMMITTED</span>

    <span class="n">sessions</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">control_connection</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">scheduler</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">executor</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">is_shutdown</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_setup</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_prepared_statements</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_prepared_statement_lock</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_idle_heartbeat</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_protocol_version_explicit</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_discount_down_events</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">_user_types</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A map of {keyspace: {type_name: UserType}}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_listeners</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_listener_lock</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">contact_points</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">],</span>
                 <span class="n">port</span><span class="o">=</span><span class="mi">9042</span><span class="p">,</span>
                 <span class="n">compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">auth_provider</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">load_balancing_policy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reconnection_policy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">default_retry_policy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">conviction_policy_factory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">metrics_enabled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">connection_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ssl_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sockopts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cql_version</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">protocol_version</span><span class="o">=</span><span class="n">_NOT_SET</span><span class="p">,</span>
                 <span class="n">executor_threads</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">max_schema_agreement_wait</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">control_connection_timeout</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                 <span class="n">idle_heartbeat_interval</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                 <span class="n">schema_event_refresh_window</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">topology_event_refresh_window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">connect_timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">schema_metadata_enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">token_metadata_enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">address_translator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">status_event_refresh_window</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">prepare_on_all_hosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">reprepare_on_up</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">execution_profiles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">allow_beta_protocol_version</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">timestamp_generator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">idle_heartbeat_timeout</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``executor_threads`` defines the number of threads in a pool for handling asynchronous tasks such as</span>
<span class="sd">        extablishing connection pools or refreshing metadata.</span>

<span class="sd">        Any of the mutable Cluster attributes may be set as keyword arguments to the constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">contact_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">contact_points</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;contact_points should not be a string, it should be a sequence (e.g. list) of strings&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">contact_points</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;contact_points should not contain None (it can resolve to localhost)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contact_points</span> <span class="o">=</span> <span class="n">contact_points</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">contact_points_resolved</span> <span class="o">=</span> <span class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contact_points</span>
                                        <span class="k">for</span> <span class="n">endpoint</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compression</span> <span class="o">=</span> <span class="n">compression</span>

        <span class="k">if</span> <span class="n">protocol_version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_NOT_SET</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span> <span class="o">=</span> <span class="n">protocol_version</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version_explicit</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_beta_protocol_version</span> <span class="o">=</span> <span class="n">allow_beta_protocol_version</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">auth_provider</span> <span class="o">=</span> <span class="n">auth_provider</span>

        <span class="k">if</span> <span class="n">load_balancing_policy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">load_balancing_policy</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;load_balancing_policy should not be a class, it should be an instance of that class&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_balancing_policy</span> <span class="o">=</span> <span class="n">load_balancing_policy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_balancing_policy</span> <span class="o">=</span> <span class="n">default_lbp_factory</span><span class="p">()</span>  <span class="c1"># set internal attribute to avoid committing to legacy config mode</span>

        <span class="k">if</span> <span class="n">reconnection_policy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reconnection_policy</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;reconnection_policy should not be a class, it should be an instance of that class&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reconnection_policy</span> <span class="o">=</span> <span class="n">reconnection_policy</span>

        <span class="k">if</span> <span class="n">default_retry_policy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default_retry_policy</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;default_retry_policy should not be a class, it should be an instance of that class&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_retry_policy</span> <span class="o">=</span> <span class="n">default_retry_policy</span>

        <span class="k">if</span> <span class="n">conviction_policy_factory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">conviction_policy_factory</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;conviction_policy_factory must be callable&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conviction_policy_factory</span> <span class="o">=</span> <span class="n">conviction_policy_factory</span>

        <span class="k">if</span> <span class="n">address_translator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">address_translator</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;address_translator should not be a class, it should be an instance of that class&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">address_translator</span> <span class="o">=</span> <span class="n">address_translator</span>

        <span class="k">if</span> <span class="n">connection_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection_class</span> <span class="o">=</span> <span class="n">connection_class</span>

        <span class="k">if</span> <span class="n">timestamp_generator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">timestamp_generator</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;timestamp_generator must be callable&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp_generator</span> <span class="o">=</span> <span class="n">timestamp_generator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp_generator</span> <span class="o">=</span> <span class="n">MonotonicTimestampGenerator</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span> <span class="o">=</span> <span class="n">ProfileManager</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">profiles</span><span class="p">[</span><span class="n">EXEC_PROFILE_DEFAULT</span><span class="p">]</span> <span class="o">=</span> <span class="n">ExecutionProfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="p">,</span>
                                                                               <span class="bp">self</span><span class="o">.</span><span class="n">default_retry_policy</span><span class="p">,</span>
                                                                               <span class="n">Session</span><span class="o">.</span><span class="n">_default_consistency_level</span><span class="p">,</span>
                                                                               <span class="n">Session</span><span class="o">.</span><span class="n">_default_serial_consistency_level</span><span class="p">,</span>
                                                                               <span class="n">Session</span><span class="o">.</span><span class="n">_default_timeout</span><span class="p">,</span>
                                                                               <span class="n">Session</span><span class="o">.</span><span class="n">_row_factory</span><span class="p">)</span>
        <span class="c1"># legacy mode if either of these is not default</span>
        <span class="k">if</span> <span class="n">load_balancing_policy</span> <span class="ow">or</span> <span class="n">default_retry_policy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">execution_profiles</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Clusters constructed with execution_profiles should not specify legacy parameters &quot;</span>
                                 <span class="s2">&quot;load_balancing_policy or default_retry_policy. Configure this in a profile instead.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">=</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">LEGACY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">execution_profiles</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">profiles</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">execution_profiles</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">=</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">PROFILES</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metrics_enabled</span> <span class="o">=</span> <span class="n">metrics_enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssl_options</span> <span class="o">=</span> <span class="n">ssl_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sockopts</span> <span class="o">=</span> <span class="n">sockopts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cql_version</span> <span class="o">=</span> <span class="n">cql_version</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_schema_agreement_wait</span> <span class="o">=</span> <span class="n">max_schema_agreement_wait</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection_timeout</span> <span class="o">=</span> <span class="n">control_connection_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idle_heartbeat_interval</span> <span class="o">=</span> <span class="n">idle_heartbeat_interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idle_heartbeat_timeout</span> <span class="o">=</span> <span class="n">idle_heartbeat_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema_event_refresh_window</span> <span class="o">=</span> <span class="n">schema_event_refresh_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology_event_refresh_window</span> <span class="o">=</span> <span class="n">topology_event_refresh_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status_event_refresh_window</span> <span class="o">=</span> <span class="n">status_event_refresh_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect_timeout</span> <span class="o">=</span> <span class="n">connect_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_on_all_hosts</span> <span class="o">=</span> <span class="n">prepare_on_all_hosts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reprepare_on_up</span> <span class="o">=</span> <span class="n">reprepare_on_up</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_listeners</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_listener_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

        <span class="c1"># let Session objects be GC&#39;ed (and shutdown) when the user no longer</span>
        <span class="c1"># holds a reference.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span> <span class="o">=</span> <span class="n">WeakSet</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepared_statements</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepared_statement_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_types</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_min_requests_per_connection</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">:</span> <span class="n">DEFAULT_MIN_REQUESTS</span><span class="p">,</span>
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span> <span class="n">DEFAULT_MIN_REQUESTS</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_max_requests_per_connection</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">:</span> <span class="n">DEFAULT_MAX_REQUESTS</span><span class="p">,</span>
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span> <span class="n">DEFAULT_MAX_REQUESTS</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_core_connections_per_host</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">:</span> <span class="n">DEFAULT_MIN_CONNECTIONS_PER_LOCAL_HOST</span><span class="p">,</span>
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span> <span class="n">DEFAULT_MIN_CONNECTIONS_PER_REMOTE_HOST</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_max_connections_per_host</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">LOCAL</span><span class="p">:</span> <span class="n">DEFAULT_MAX_CONNECTIONS_PER_LOCAL_HOST</span><span class="p">,</span>
            <span class="n">HostDistance</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span> <span class="n">DEFAULT_MAX_CONNECTIONS_PER_REMOTE_HOST</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">executor</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">executor_threads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">_Scheduler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">executor</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics_enabled</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">cassandra.metrics</span> <span class="k">import</span> <span class="n">Metrics</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">Metrics</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span> <span class="o">=</span> <span class="n">ControlConnection</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection_timeout</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schema_event_refresh_window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology_event_refresh_window</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">status_event_refresh_window</span><span class="p">,</span>
            <span class="n">schema_metadata_enabled</span><span class="p">,</span> <span class="n">token_metadata_enabled</span><span class="p">)</span>

<div class="viewcode-block" id="Cluster.register_user_type"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.register_user_type">[docs]</a>    <span class="k">def</span> <span class="nf">register_user_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">user_type</span><span class="p">,</span> <span class="n">klass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a class to use to represent a particular user-defined type.</span>
<span class="sd">        Query parameters for this user-defined type will be assumed to be</span>
<span class="sd">        instances of `klass`.  Result sets for this user-defined type will</span>
<span class="sd">        be instances of `klass`.  If no class is registered for a user-defined</span>
<span class="sd">        type, a namedtuple will be used for result sets, and non-prepared</span>
<span class="sd">        statements may not encode parameters for this type correctly.</span>

<span class="sd">        `keyspace` is the name of the keyspace that the UDT is defined in.</span>

<span class="sd">        `user_type` is the string name of the UDT to register the mapping</span>
<span class="sd">        for.</span>

<span class="sd">        `klass` should be a class with attributes whose names match the</span>
<span class="sd">        fields of the user-defined type.  The constructor must accepts kwargs</span>
<span class="sd">        for each of the fields in the UDT.</span>

<span class="sd">        This method should only be called after the type has been created</span>
<span class="sd">        within Cassandra.</span>

<span class="sd">        Example::</span>

<span class="sd">            cluster = Cluster(protocol_version=3)</span>
<span class="sd">            session = cluster.connect()</span>
<span class="sd">            session.set_keyspace(&#39;mykeyspace&#39;)</span>
<span class="sd">            session.execute(&quot;CREATE TYPE address (street text, zipcode int)&quot;)</span>
<span class="sd">            session.execute(&quot;CREATE TABLE users (id int PRIMARY KEY, location address)&quot;)</span>

<span class="sd">            # create a class to map to the &quot;address&quot; UDT</span>
<span class="sd">            class Address(object):</span>

<span class="sd">                def __init__(self, street, zipcode):</span>
<span class="sd">                    self.street = street</span>
<span class="sd">                    self.zipcode = zipcode</span>

<span class="sd">            cluster.register_user_type(&#39;mykeyspace&#39;, &#39;address&#39;, Address)</span>

<span class="sd">            # insert a row using an instance of Address</span>
<span class="sd">            session.execute(&quot;INSERT INTO users (id, location) VALUES (%s, %s)&quot;,</span>
<span class="sd">                            (0, Address(&quot;123 Main St.&quot;, 78723)))</span>

<span class="sd">            # results will include Address instances</span>
<span class="sd">            results = session.execute(&quot;SELECT * FROM users&quot;)</span>
<span class="sd">            row = results[0]</span>
<span class="sd">            print row.id, row.location.street, row.location.zipcode</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;User Type serialization is only supported in native protocol version 3+ (</span><span class="si">%d</span><span class="s2"> in use). &quot;</span>
                        <span class="s2">&quot;CQL encoding for simple statements will still work, but named tuples will &quot;</span>
                        <span class="s2">&quot;be returned when reading type </span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">user_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_types</span><span class="p">[</span><span class="n">keyspace</span><span class="p">][</span><span class="n">user_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">klass</span>
        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">user_type_registered</span><span class="p">(</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">user_type</span><span class="p">,</span> <span class="n">klass</span><span class="p">)</span>
        <span class="n">UserType</span><span class="o">.</span><span class="n">evict_udt_class</span><span class="p">(</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">user_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.add_execution_profile"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.add_execution_profile">[docs]</a>    <span class="k">def</span> <span class="nf">add_execution_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">pool_wait_timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an :class:`.ExecutionProfile` to the cluster. This makes it available for use by ``name`` in :meth:`.Session.execute`</span>
<span class="sd">        and :meth:`.Session.execute_async`. This method will raise if the profile already exists.</span>

<span class="sd">        Normally profiles will be injected at cluster initialization via ``Cluster(execution_profiles)``. This method</span>
<span class="sd">        provides a way of adding them dynamically.</span>

<span class="sd">        Adding a new profile updates the connection pools according to the specified ``load_balancing_policy``. By default,</span>
<span class="sd">        this method will wait up to five seconds for the pool creation to complete, so the profile can be used immediately</span>
<span class="sd">        upon return. This behavior can be controlled using ``pool_wait_timeout`` (see</span>
<span class="sd">        `concurrent.futures.wait &lt;https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.wait&gt;`_</span>
<span class="sd">        for timeout semantics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">ExecutionProfile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;profile must be an instance of ExecutionProfile&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">==</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">LEGACY</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add execution profiles when legacy parameters are set explicitly.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">profiles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Profile </span><span class="si">%s</span><span class="s2"> already exists&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">profiles</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span>
        <span class="n">profile</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">all_hosts</span><span class="p">())</span>
        <span class="c1"># on_up after populate allows things like DCA LBP to choose default local dc</span>
        <span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">h</span><span class="p">:</span> <span class="n">h</span><span class="o">.</span><span class="n">is_up</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">all_hosts</span><span class="p">()):</span>
            <span class="n">profile</span><span class="o">.</span><span class="n">load_balancing_policy</span><span class="o">.</span><span class="n">on_up</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">futures</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">session</span><span class="o">.</span><span class="n">update_created_pools</span><span class="p">())</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">not_done</span> <span class="o">=</span> <span class="n">wait_futures</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">pool_wait_timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">not_done</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OperationTimedOut</span><span class="p">(</span><span class="s2">&quot;Failed to create all new connection pools in the </span><span class="si">%s</span><span class="s2">s timeout.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cluster.get_min_requests_per_connection"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.get_min_requests_per_connection">[docs]</a>    <span class="k">def</span> <span class="nf">get_min_requests_per_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host_distance</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_requests_per_connection</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cluster.set_min_requests_per_connection"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.set_min_requests_per_connection">[docs]</a>    <span class="k">def</span> <span class="nf">set_min_requests_per_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host_distance</span><span class="p">,</span> <span class="n">min_requests</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a threshold for concurrent requests per connection, below which</span>
<span class="sd">        connections will be considered for disposal (down to core connections;</span>
<span class="sd">        see :meth:`~Cluster.set_core_connections_per_host`).</span>

<span class="sd">        Pertains to connection pool management in protocol versions {1,2}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span>
                <span class="s2">&quot;Cluster.set_min_requests_per_connection() only has an effect &quot;</span>
                <span class="s2">&quot;when using protocol_version 1 or 2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_requests</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">min_requests</span> <span class="o">&gt;</span> <span class="mi">126</span> <span class="ow">or</span> \
           <span class="n">min_requests</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_requests_per_connection</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_requests must be 0-126 and less than the max_requests for this host_distance (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_requests_per_connection</span><span class="p">[</span><span class="n">host_distance</span><span class="p">],))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_requests_per_connection</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_requests</span></div>

<div class="viewcode-block" id="Cluster.get_max_requests_per_connection"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.get_max_requests_per_connection">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_requests_per_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host_distance</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_requests_per_connection</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cluster.set_max_requests_per_connection"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.set_max_requests_per_connection">[docs]</a>    <span class="k">def</span> <span class="nf">set_max_requests_per_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host_distance</span><span class="p">,</span> <span class="n">max_requests</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a threshold for concurrent requests per connection, above which new</span>
<span class="sd">        connections will be created to a host (up to max connections;</span>
<span class="sd">        see :meth:`~Cluster.set_max_connections_per_host`).</span>

<span class="sd">        Pertains to connection pool management in protocol versions {1,2}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span>
                <span class="s2">&quot;Cluster.set_max_requests_per_connection() only has an effect &quot;</span>
                <span class="s2">&quot;when using protocol_version 1 or 2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_requests</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">max_requests</span> <span class="o">&gt;</span> <span class="mi">127</span> <span class="ow">or</span> \
           <span class="n">max_requests</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_requests_per_connection</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_requests must be 1-127 and greater than the min_requests for this host_distance (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_requests_per_connection</span><span class="p">[</span><span class="n">host_distance</span><span class="p">],))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_requests_per_connection</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_requests</span></div>

<div class="viewcode-block" id="Cluster.get_core_connections_per_host"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.get_core_connections_per_host">[docs]</a>    <span class="k">def</span> <span class="nf">get_core_connections_per_host</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host_distance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the minimum number of connections per Session that will be opened</span>
<span class="sd">        for each host with :class:`~.HostDistance` equal to `host_distance`.</span>
<span class="sd">        The default is 2 for :attr:`~HostDistance.LOCAL` and 1 for</span>
<span class="sd">        :attr:`~HostDistance.REMOTE`.</span>

<span class="sd">        This property is ignored if :attr:`~.Cluster.protocol_version` is</span>
<span class="sd">        3 or higher.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_core_connections_per_host</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cluster.set_core_connections_per_host"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.set_core_connections_per_host">[docs]</a>    <span class="k">def</span> <span class="nf">set_core_connections_per_host</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host_distance</span><span class="p">,</span> <span class="n">core_connections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the minimum number of connections per Session that will be opened</span>
<span class="sd">        for each host with :class:`~.HostDistance` equal to `host_distance`.</span>
<span class="sd">        The default is 2 for :attr:`~HostDistance.LOCAL` and 1 for</span>
<span class="sd">        :attr:`~HostDistance.REMOTE`.</span>

<span class="sd">        Protocol version 1 and 2 are limited in the number of concurrent</span>
<span class="sd">        requests they can send per connection. The driver implements connection</span>
<span class="sd">        pooling to support higher levels of concurrency.</span>

<span class="sd">        If :attr:`~.Cluster.protocol_version` is set to 3 or higher, this</span>
<span class="sd">        is not supported (there is always one connection per host, unless</span>
<span class="sd">        the host is remote and :attr:`connect_to_remote_hosts` is :const:`False`)</span>
<span class="sd">        and using this will result in an :exc:`~.UnsupporteOperation`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span>
                <span class="s2">&quot;Cluster.set_core_connections_per_host() only has an effect &quot;</span>
                <span class="s2">&quot;when using protocol_version 1 or 2.&quot;</span><span class="p">)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_core_connections_per_host</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_core_connections_per_host</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_connections</span>
        <span class="k">if</span> <span class="n">old</span> <span class="o">&lt;</span> <span class="n">core_connections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_core_connections</span><span class="p">()</span></div>

<div class="viewcode-block" id="Cluster.get_max_connections_per_host"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.get_max_connections_per_host">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_connections_per_host</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host_distance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the maximum number of connections per Session that will be opened</span>
<span class="sd">        for each host with :class:`~.HostDistance` equal to `host_distance`.</span>
<span class="sd">        The default is 8 for :attr:`~HostDistance.LOCAL` and 2 for</span>
<span class="sd">        :attr:`~HostDistance.REMOTE`.</span>

<span class="sd">        This property is ignored if :attr:`~.Cluster.protocol_version` is</span>
<span class="sd">        3 or higher.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_connections_per_host</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cluster.set_max_connections_per_host"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.set_max_connections_per_host">[docs]</a>    <span class="k">def</span> <span class="nf">set_max_connections_per_host</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host_distance</span><span class="p">,</span> <span class="n">max_connections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the maximum number of connections per Session that will be opened</span>
<span class="sd">        for each host with :class:`~.HostDistance` equal to `host_distance`.</span>
<span class="sd">        The default is 2 for :attr:`~HostDistance.LOCAL` and 1 for</span>
<span class="sd">        :attr:`~HostDistance.REMOTE`.</span>

<span class="sd">        If :attr:`~.Cluster.protocol_version` is set to 3 or higher, this</span>
<span class="sd">        is not supported (there is always one connection per host, unless</span>
<span class="sd">        the host is remote and :attr:`connect_to_remote_hosts` is :const:`False`)</span>
<span class="sd">        and using this will result in an :exc:`~.UnsupporteOperation`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span>
                <span class="s2">&quot;Cluster.set_max_connections_per_host() only has an effect &quot;</span>
                <span class="s2">&quot;when using protocol_version 1 or 2.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_connections_per_host</span><span class="p">[</span><span class="n">host_distance</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_connections</span></div>

    <span class="k">def</span> <span class="nf">connection_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called to create a new connection with proper configuration.</span>
<span class="sd">        Intended for internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_connection_kwargs</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_class</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_timeout</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_connection_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_connection_kwargs</span><span class="p">(</span><span class="n">host</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection_class</span><span class="o">.</span><span class="n">factory</span><span class="p">,</span> <span class="n">host</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_timeout</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_connection_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">kwargs_dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auth_provider_callable</span><span class="p">:</span>
            <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;authenticator&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auth_provider_callable</span><span class="p">(</span><span class="n">address</span><span class="p">))</span>

        <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;port&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
        <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;compression&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compression</span><span class="p">)</span>
        <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sockopts&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sockopts</span><span class="p">)</span>
        <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ssl_options&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssl_options</span><span class="p">)</span>
        <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;cql_version&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cql_version</span><span class="p">)</span>
        <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;protocol_version&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span><span class="p">)</span>
        <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;user_type_map&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_types</span><span class="p">)</span>
        <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;allow_beta_protocol_version&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_beta_protocol_version</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kwargs_dict</span>

    <span class="k">def</span> <span class="nf">protocol_downgrade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host_addr</span><span class="p">,</span> <span class="n">previous_version</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version_explicit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;ProtocolError returned from server while using explicitly set client protocol_version </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">previous_version</span><span class="p">,))</span>

        <span class="n">new_version</span> <span class="o">=</span> <span class="n">ProtocolVersion</span><span class="o">.</span><span class="n">get_lower_supported</span><span class="p">(</span><span class="n">previous_version</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_version</span> <span class="o">&lt;</span> <span class="n">ProtocolVersion</span><span class="o">.</span><span class="n">MIN_SUPPORTED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span>
                <span class="s2">&quot;Cannot downgrade protocol version below minimum supported version: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ProtocolVersion</span><span class="o">.</span><span class="n">MIN_SUPPORTED</span><span class="p">,))</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Downgrading core protocol version from </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2"> for </span><span class="si">%s</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;To avoid this, it is best practice to explicitly set Cluster(protocol_version) to the version supported by your cluster. &quot;</span>
                    <span class="s2">&quot;http://datastax.github.io/python-driver/api/cassandra/cluster.html#cassandra.cluster.Cluster.protocol_version&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span><span class="p">,</span> <span class="n">new_version</span><span class="p">,</span> <span class="n">host_addr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span> <span class="o">=</span> <span class="n">new_version</span>

<div class="viewcode-block" id="Cluster.connect"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wait_for_all_pools</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a new :class:`~.Session` object.  If `keyspace`</span>
<span class="sd">        is specified, that keyspace will be the default keyspace for</span>
<span class="sd">        operations on the ``Session``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;Cluster is already shut down&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_setup</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Connecting to cluster, contact points: </span><span class="si">%s</span><span class="s2">; protocol version: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">contact_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">protocol_version</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connection_class</span><span class="o">.</span><span class="n">initialize_reactor</span><span class="p">()</span>
                <span class="n">_register_cluster_shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contact_points_resolved</span><span class="p">:</span>
                    <span class="n">host</span><span class="p">,</span> <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_host</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new</span><span class="p">:</span>
                        <span class="n">host</span><span class="o">.</span><span class="n">set_up</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
                            <span class="n">listener</span><span class="o">.</span><span class="n">on_add</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span>
                    <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">all_hosts</span><span class="p">())</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

                    <span class="c1"># we set all contact points up for connecting, but we won&#39;t infer state after this</span>
                    <span class="k">for</span> <span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contact_points_resolved</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_host</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">h</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span><span class="p">:</span>
                            <span class="n">h</span><span class="o">.</span><span class="n">is_up</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Control connection created&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Control connection failed to connect, &quot;</span>
                                  <span class="s2">&quot;shutting down Cluster:&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
                    <span class="k">raise</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">check_supported</span><span class="p">()</span>  <span class="c1"># todo: rename this method</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idle_heartbeat_interval</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_idle_heartbeat</span> <span class="o">=</span> <span class="n">ConnectionHeartbeat</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">idle_heartbeat_interval</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_connection_holders</span><span class="p">,</span>
                        <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">idle_heartbeat_timeout</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_setup</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">session</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_session</span><span class="p">(</span><span class="n">keyspace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wait_for_all_pools</span><span class="p">:</span>
            <span class="n">wait_futures</span><span class="p">(</span><span class="n">session</span><span class="o">.</span><span class="n">_initial_connect_futures</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">session</span></div>

    <span class="k">def</span> <span class="nf">get_connection_holders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">holders</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">holders</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">get_pools</span><span class="p">())</span>
        <span class="n">holders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">holders</span>

<div class="viewcode-block" id="Cluster.shutdown"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.shutdown">[docs]</a>    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Closes all sessions and connection associated with this Cluster.</span>
<span class="sd">        To ensure all connections are properly closed, **you should always</span>
<span class="sd">        call shutdown() on a Cluster instance when you are done with it**.</span>

<span class="sd">        Once shutdown, a Cluster should not be used for any purpose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idle_heartbeat</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idle_heartbeat</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">executor</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

        <span class="n">_discard_cluster_shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_new_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">):</span>
        <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">all_hosts</span><span class="p">(),</span> <span class="n">keyspace</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_session_register_user_types</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">session</span>

    <span class="k">def</span> <span class="nf">_session_register_user_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">type_map</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_user_types</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">udt_name</span><span class="p">,</span> <span class="n">klass</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">type_map</span><span class="p">):</span>
                <span class="n">session</span><span class="o">.</span><span class="n">user_type_registered</span><span class="p">(</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">udt_name</span><span class="p">,</span> <span class="n">klass</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cleanup_failed_on_up_handling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">remove_pool</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start_reconnector</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_on_up_future_completed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">futures</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">finished_future</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
            <span class="n">futures</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">finished_future</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">finished_future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">futures</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># all futures have completed at this point</span>
            <span class="k">for</span> <span class="n">exc</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)]:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unexpected failure while marking node </span><span class="si">%s</span><span class="s2"> up:&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_failed_on_up_handling</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Connection pool could not be created, not marking node </span><span class="si">%s</span><span class="s2"> up&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_failed_on_up_handling</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Connection pools established for node </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="c1"># mark the host as up and notify all listeners</span>
            <span class="n">host</span><span class="o">.</span><span class="n">set_up</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
                <span class="n">listener</span><span class="o">.</span><span class="n">on_up</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">host</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                <span class="n">host</span><span class="o">.</span><span class="n">_currently_handling_node_up</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># see if there are any pools to add or remove now that the host is marked up</span>
        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">update_created_pools</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intended for internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Waiting to acquire lock for handling up status of node </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">host</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">host</span><span class="o">.</span><span class="n">_currently_handling_node_up</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Another thread is already handling up status of node </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">host</span><span class="o">.</span><span class="n">is_up</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Host </span><span class="si">%s</span><span class="s2"> was already marked up&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="n">host</span><span class="o">.</span><span class="n">_currently_handling_node_up</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Starting to handle up status of node </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

        <span class="n">have_future</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Host </span><span class="si">%s</span><span class="s2"> may be up; will prepare queries and open connection pool&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

            <span class="n">reconnector</span> <span class="o">=</span> <span class="n">host</span><span class="o">.</span><span class="n">get_and_set_reconnection_handler</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reconnector</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Now that host </span><span class="si">%s</span><span class="s2"> is up, cancelling the reconnection handler&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
                <span class="n">reconnector</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_all_queries</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Done preparing all queries for host </span><span class="si">%s</span><span class="s2">, &quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
                <span class="n">session</span><span class="o">.</span><span class="n">remove_pool</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Signalling to load balancing policies that host </span><span class="si">%s</span><span class="s2"> is up&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">on_up</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Signalling to control connection that host </span><span class="si">%s</span><span class="s2"> is up&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">on_up</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Attempting to open new connection pools for host </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="n">futures_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
            <span class="n">futures_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_up_future_completed</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">futures</span><span class="p">,</span> <span class="n">futures_results</span><span class="p">,</span> <span class="n">futures_lock</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
                <span class="n">future</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">add_or_renew_pool</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">have_future</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
                    <span class="n">futures</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Unexpected failure handling node </span><span class="si">%s</span><span class="s2"> being marked up:&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
                <span class="n">future</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_failed_on_up_handling</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">host</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                <span class="n">host</span><span class="o">.</span><span class="n">_currently_handling_node_up</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">have_future</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">host</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                    <span class="n">host</span><span class="o">.</span><span class="n">set_up</span><span class="p">()</span>
                    <span class="n">host</span><span class="o">.</span><span class="n">_currently_handling_node_up</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># for testing purposes</span>
        <span class="k">return</span> <span class="n">futures</span>

    <span class="k">def</span> <span class="nf">_start_reconnector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="o">==</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">schedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconnection_policy</span><span class="o">.</span><span class="n">new_schedule</span><span class="p">()</span>

        <span class="c1"># in order to not hold references to this Cluster open and prevent</span>
        <span class="c1"># proper shutdown when the program ends, we&#39;ll just make a closure</span>
        <span class="c1"># of the current Cluster attributes to create new Connections with</span>
        <span class="n">conn_factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_connection_factory</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

        <span class="n">reconnector</span> <span class="o">=</span> <span class="n">_HostReconnectionHandler</span><span class="p">(</span>
            <span class="n">host</span><span class="p">,</span> <span class="n">conn_factory</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_up</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">host</span><span class="o">.</span><span class="n">get_and_set_reconnection_handler</span><span class="p">,</span>
            <span class="n">new_handler</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">old_reconnector</span> <span class="o">=</span> <span class="n">host</span><span class="o">.</span><span class="n">get_and_set_reconnection_handler</span><span class="p">(</span><span class="n">reconnector</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old_reconnector</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Old host reconnector found for </span><span class="si">%s</span><span class="s2">, cancelling&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="n">old_reconnector</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Starting reconnector for host </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
        <span class="n">reconnector</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="nd">@run_in_executor</span>
    <span class="k">def</span> <span class="nf">on_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">,</span> <span class="n">expect_host_to_be_down</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intended for internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">with</span> <span class="n">host</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="n">was_up</span> <span class="o">=</span> <span class="n">host</span><span class="o">.</span><span class="n">is_up</span>

            <span class="c1"># ignore down signals if we have open pools to the host</span>
            <span class="c1"># this is to avoid closing pools when a control connection host became isolated</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discount_down_events</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span><span class="p">:</span>
                <span class="n">connected</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
                    <span class="n">pool_states</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get_pool_state</span><span class="p">()</span>
                    <span class="n">pool_state</span> <span class="o">=</span> <span class="n">pool_states</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pool_state</span><span class="p">:</span>
                        <span class="n">connected</span> <span class="o">|=</span> <span class="n">pool_state</span><span class="p">[</span><span class="s1">&#39;open_count&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">connected</span><span class="p">:</span>
                    <span class="k">return</span>

            <span class="n">host</span><span class="o">.</span><span class="n">set_down</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">was_up</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expect_host_to_be_down</span><span class="p">)</span> <span class="ow">or</span> <span class="n">host</span><span class="o">.</span><span class="n">is_currently_reconnecting</span><span class="p">():</span>
                <span class="k">return</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Host </span><span class="si">%s</span><span class="s2"> has been marked down&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
            <span class="n">listener</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start_reconnector</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">refresh_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Handling new host </span><span class="si">%r</span><span class="s2"> and notifying listeners&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">!=</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_all_queries</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Done preparing queries for new host </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">on_add</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">on_add</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">refresh_nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">distance</span> <span class="o">==</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Not adding connection pool for new host </span><span class="si">%r</span><span class="s2"> because the &quot;</span>
                      <span class="s2">&quot;load balancing policy has marked it as IGNORED&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_add</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">set_up</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">futures_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
        <span class="n">futures_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">future_completed</span><span class="p">(</span><span class="n">future</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">futures_lock</span><span class="p">:</span>
                <span class="n">futures</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">futures_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="n">futures_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">futures</span><span class="p">:</span>
                    <span class="k">return</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;All futures have completed for added host </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">exc</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">futures_results</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)]:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unexpected failure while adding node </span><span class="si">%s</span><span class="s2">, will not mark up:&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">futures_results</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Connection pool could not be created, not marking node </span><span class="si">%s</span><span class="s2"> up&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_add</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

        <span class="n">have_future</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">future</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">add_or_renew_pool</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">have_future</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">futures</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
                <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">future_completed</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">have_future</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_add</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_finalize_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">set_up</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">set_up</span><span class="p">:</span>
            <span class="n">host</span><span class="o">.</span><span class="n">set_up</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
            <span class="n">listener</span><span class="o">.</span><span class="n">on_add</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

        <span class="c1"># see if there are any pools to add or remove now that the host is marked up</span>
        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">update_created_pools</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Removing host </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
        <span class="n">host</span><span class="o">.</span><span class="n">set_down</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">on_remove</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">on_remove</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
            <span class="n">listener</span><span class="o">.</span><span class="n">on_remove</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">on_remove</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">signal_connection_failure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">connection_exc</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">,</span> <span class="n">expect_host_to_be_down</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">is_down</span> <span class="o">=</span> <span class="n">host</span><span class="o">.</span><span class="n">signal_connection_failure</span><span class="p">(</span><span class="n">connection_exc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_down</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">,</span> <span class="n">expect_host_to_be_down</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">is_down</span>

    <span class="k">def</span> <span class="nf">add_host</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">datacenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rack</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">refresh_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when adding initial contact points and when the control</span>
<span class="sd">        connection subsequently discovers a new node.</span>
<span class="sd">        Returns a Host instance, and a flag indicating whether it was new in</span>
<span class="sd">        the metadata.</span>
<span class="sd">        Intended for internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">host</span><span class="p">,</span> <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">add_or_return_host</span><span class="p">(</span><span class="n">Host</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conviction_policy_factory</span><span class="p">,</span> <span class="n">datacenter</span><span class="p">,</span> <span class="n">rack</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">and</span> <span class="n">signal</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;New Cassandra host </span><span class="si">%r</span><span class="s2"> discovered&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_add</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">refresh_nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">host</span><span class="p">,</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">remove_host</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when the control connection observes that a node has left the</span>
<span class="sd">        ring.  Intended for internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">host</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">remove_host</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cassandra host </span><span class="si">%s</span><span class="s2"> removed&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_remove</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

<div class="viewcode-block" id="Cluster.register_listener"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.register_listener">[docs]</a>    <span class="k">def</span> <span class="nf">register_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listener</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a :class:`cassandra.policies.HostStateListener` subclass instance to</span>
<span class="sd">        the list of listeners to be notified when a host is added, removed,</span>
<span class="sd">        marked up, or marked down.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listener_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_listeners</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.unregister_listener"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.unregister_listener">[docs]</a>    <span class="k">def</span> <span class="nf">unregister_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listener</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Removes a registered listener. &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listener_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_listeners</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">listeners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listener_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listeners</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_ensure_core_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If any host has fewer than the configured number of core connections</span>
<span class="sd">        open, attempt to open connections until that number is met.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">session</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sessions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">session</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">ensure_core_connections</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_refresh_schema</span><span class="p">(</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">usertype</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">table</span><span class="p">,</span> <span class="n">usertype</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keyspace</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;keyspace is required to refresh specific sub-entity {table, usertype, function, aggregate}&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">usertype</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span> <span class="k">if</span> <span class="n">e</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;{table, usertype, function, aggregate} are mutually exclusive&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_target_type_from_refresh_args</span><span class="p">(</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">usertype</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">aggregate</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">AGGREGATE</span>
        <span class="k">elif</span> <span class="n">function</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">FUNCTION</span>
        <span class="k">elif</span> <span class="n">usertype</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">TYPE</span>
        <span class="k">elif</span> <span class="n">table</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">TABLE</span>
        <span class="k">elif</span> <span class="n">keyspace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">KEYSPACE</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Cluster.get_control_connection_host"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.get_control_connection_host">[docs]</a>    <span class="k">def</span> <span class="nf">get_control_connection_host</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the control connection host metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">_connection</span>
        <span class="n">host</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">host</span> <span class="k">if</span> <span class="n">connection</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_host</span><span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="k">if</span> <span class="n">host</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Cluster.refresh_schema_metadata"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.refresh_schema_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">refresh_schema_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_schema_agreement_wait</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously refresh all schema metadata.</span>

<span class="sd">        By default, the timeout for this operation is governed by :attr:`~.Cluster.max_schema_agreement_wait`</span>
<span class="sd">        and :attr:`~.Cluster.control_connection_timeout`.</span>

<span class="sd">        Passing max_schema_agreement_wait here overrides :attr:`~.Cluster.max_schema_agreement_wait`.</span>

<span class="sd">        Setting max_schema_agreement_wait &lt;= 0 will bypass schema agreement and refresh schema immediately.</span>

<span class="sd">        An Exception is raised if schema refresh fails for any reason.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">refresh_schema</span><span class="p">(</span><span class="n">schema_agreement_wait</span><span class="o">=</span><span class="n">max_schema_agreement_wait</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;Schema metadata was not refreshed. See log for details.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.refresh_keyspace_metadata"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.refresh_keyspace_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">refresh_keyspace_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">max_schema_agreement_wait</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously refresh keyspace metadata. This applies to keyspace-level information such as replication</span>
<span class="sd">        and durability settings. It does not refresh tables, types, etc. contained in the keyspace.</span>

<span class="sd">        See :meth:`~.Cluster.refresh_schema_metadata` for description of ``max_schema_agreement_wait`` behavior</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">refresh_schema</span><span class="p">(</span><span class="n">target_type</span><span class="o">=</span><span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">KEYSPACE</span><span class="p">,</span> <span class="n">keyspace</span><span class="o">=</span><span class="n">keyspace</span><span class="p">,</span>
                                                      <span class="n">schema_agreement_wait</span><span class="o">=</span><span class="n">max_schema_agreement_wait</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;Keyspace metadata was not refreshed. See log for details.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.refresh_table_metadata"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.refresh_table_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">refresh_table_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">max_schema_agreement_wait</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously refresh table metadata. This applies to a table, and any triggers or indexes attached</span>
<span class="sd">        to the table.</span>

<span class="sd">        See :meth:`~.Cluster.refresh_schema_metadata` for description of ``max_schema_agreement_wait`` behavior</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">refresh_schema</span><span class="p">(</span><span class="n">target_type</span><span class="o">=</span><span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">TABLE</span><span class="p">,</span> <span class="n">keyspace</span><span class="o">=</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="p">,</span>
                                                      <span class="n">schema_agreement_wait</span><span class="o">=</span><span class="n">max_schema_agreement_wait</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;Table metadata was not refreshed. See log for details.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">refresh_materialized_view_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">max_schema_agreement_wait</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously refresh materialized view metadata.</span>

<span class="sd">        See :meth:`~.Cluster.refresh_schema_metadata` for description of ``max_schema_agreement_wait`` behavior</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">refresh_schema</span><span class="p">(</span><span class="n">target_type</span><span class="o">=</span><span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">TABLE</span><span class="p">,</span> <span class="n">keyspace</span><span class="o">=</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="n">view</span><span class="p">,</span>
                                                      <span class="n">schema_agreement_wait</span><span class="o">=</span><span class="n">max_schema_agreement_wait</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;View metadata was not refreshed. See log for details.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Cluster.refresh_user_type_metadata"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.refresh_user_type_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">refresh_user_type_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">user_type</span><span class="p">,</span> <span class="n">max_schema_agreement_wait</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously refresh user defined type metadata.</span>

<span class="sd">        See :meth:`~.Cluster.refresh_schema_metadata` for description of ``max_schema_agreement_wait`` behavior</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">refresh_schema</span><span class="p">(</span><span class="n">target_type</span><span class="o">=</span><span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">keyspace</span><span class="o">=</span><span class="n">keyspace</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">user_type</span><span class="p">,</span>
                                                      <span class="n">schema_agreement_wait</span><span class="o">=</span><span class="n">max_schema_agreement_wait</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;User Type metadata was not refreshed. See log for details.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.refresh_user_function_metadata"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.refresh_user_function_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">refresh_user_function_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">max_schema_agreement_wait</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously refresh user defined function metadata.</span>

<span class="sd">        ``function`` is a :class:`cassandra.UserFunctionDescriptor`.</span>

<span class="sd">        See :meth:`~.Cluster.refresh_schema_metadata` for description of ``max_schema_agreement_wait`` behavior</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">refresh_schema</span><span class="p">(</span><span class="n">target_type</span><span class="o">=</span><span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span> <span class="n">keyspace</span><span class="o">=</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">,</span>
                                                      <span class="n">schema_agreement_wait</span><span class="o">=</span><span class="n">max_schema_agreement_wait</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;User Function metadata was not refreshed. See log for details.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.refresh_user_aggregate_metadata"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.refresh_user_aggregate_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">refresh_user_aggregate_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">max_schema_agreement_wait</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously refresh user defined aggregate metadata.</span>

<span class="sd">        ``aggregate`` is a :class:`cassandra.UserAggregateDescriptor`.</span>

<span class="sd">        See :meth:`~.Cluster.refresh_schema_metadata` for description of ``max_schema_agreement_wait`` behavior</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">refresh_schema</span><span class="p">(</span><span class="n">target_type</span><span class="o">=</span><span class="n">SchemaTargetType</span><span class="o">.</span><span class="n">AGGREGATE</span><span class="p">,</span> <span class="n">keyspace</span><span class="o">=</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="n">aggregate</span><span class="p">,</span>
                                                      <span class="n">schema_agreement_wait</span><span class="o">=</span><span class="n">max_schema_agreement_wait</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;User Aggregate metadata was not refreshed. See log for details.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.refresh_nodes"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.refresh_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">refresh_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_token_rebuild</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously refresh the node list and token metadata</span>

<span class="sd">        `force_token_rebuild` can be used to rebuild the token map metadata, even if no new nodes are discovered.</span>

<span class="sd">        An Exception is raised if node refresh fails for any reason.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">refresh_node_list_and_token_map</span><span class="p">(</span><span class="n">force_token_rebuild</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;Node list was not refreshed. See log for details.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cluster.set_meta_refresh_enabled"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Cluster.set_meta_refresh_enabled">[docs]</a>    <span class="k">def</span> <span class="nf">set_meta_refresh_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enabled</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Deprecated:* set :attr:`~.Cluster.schema_metadata_enabled` :attr:`~.Cluster.token_metadata_enabled` instead</span>

<span class="sd">        Sets a flag to enable (True) or disable (False) all metadata refresh queries.</span>
<span class="sd">        This applies to both schema and node topology.</span>

<span class="sd">        Disabling this is useful to minimize refreshes during multiple changes.</span>

<span class="sd">        Meta refresh must be enabled for the driver to become aware of any cluster</span>
<span class="sd">        topology changes or schema updates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema_metadata_enabled</span> <span class="o">=</span> <span class="n">enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token_metadata_enabled</span> <span class="o">=</span> <span class="n">enabled</span></div>

    <span class="k">def</span> <span class="nf">_prepare_all_queries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepared_statements</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">reprepare_on_up</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Preparing all known prepared statements against host </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_factory</span><span class="p">(</span><span class="n">host</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
            <span class="n">statements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepared_statements</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">ks_statements</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">statements</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">keyspace</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">keyspace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">set_keyspace_blocking</span><span class="p">(</span><span class="n">keyspace</span><span class="p">)</span>

                <span class="c1"># prepare 10 statements at a time</span>
                <span class="n">ks_statements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ks_statements</span><span class="p">)</span>
                <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ks_statements</span><span class="p">),</span> <span class="mi">10</span><span class="p">):</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ks_statements</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">ks_chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
                    <span class="n">messages</span> <span class="o">=</span> <span class="p">[</span><span class="n">PrepareMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">query_string</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ks_chunk</span><span class="p">]</span>
                    <span class="c1"># TODO: make this timeout configurable somehow?</span>
                    <span class="n">responses</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">wait_for_responses</span><span class="p">(</span><span class="o">*</span><span class="n">messages</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">fail_on_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">success</span><span class="p">,</span> <span class="n">response</span> <span class="ow">in</span> <span class="n">responses</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Got unexpected response when preparing &quot;</span>
                                      <span class="s2">&quot;statement on host </span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Done preparing all known prepared statements against host </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">OperationTimedOut</span> <span class="k">as</span> <span class="n">timeout</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Timed out trying to prepare all statements on host </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ConnectionException</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error trying to prepare all statements on host </span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Error trying to prepare all statements on host </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">connection</span><span class="p">:</span>
                <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_prepared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_id</span><span class="p">,</span> <span class="n">prepared_statement</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepared_statement_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prepared_statements</span><span class="p">[</span><span class="n">query_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">prepared_statement</span></div>


<div class="viewcode-block" id="Session"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Session">[docs]</a><span class="k">class</span> <span class="nc">Session</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of connection pools for each host in the cluster.</span>
<span class="sd">    Instances of this class should not be created directly, only</span>
<span class="sd">    using :meth:`.Cluster.connect()`.</span>

<span class="sd">    Queries and statements can be executed through ``Session`` instances</span>
<span class="sd">    using the :meth:`~.Session.execute()` and :meth:`~.Session.execute_async()`</span>
<span class="sd">    methods.</span>

<span class="sd">    Example usage::</span>

<span class="sd">        &gt;&gt;&gt; session = cluster.connect()</span>
<span class="sd">        &gt;&gt;&gt; session.set_keyspace(&quot;mykeyspace&quot;)</span>
<span class="sd">        &gt;&gt;&gt; session.execute(&quot;SELECT * FROM mycf&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cluster</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">hosts</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">keyspace</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">is_shutdown</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_row_factory</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">named_tuple_factory</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">row_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The format to return row results in.  By default, each</span>
<span class="sd">        returned row will be a named tuple.  You can alternatively</span>
<span class="sd">        use any of the following:</span>

<span class="sd">          - :func:`cassandra.query.tuple_factory` - return a result row as a tuple</span>
<span class="sd">          - :func:`cassandra.query.named_tuple_factory` - return a result row as a named tuple</span>
<span class="sd">          - :func:`cassandra.query.dict_factory` - return a result row as a dict</span>
<span class="sd">          - :func:`cassandra.query.ordered_dict_factory` - return a result row as an OrderedDict</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_factory</span>

    <span class="nd">@row_factory</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">row_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rf</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_set_legacy_config</span><span class="p">(</span><span class="s1">&#39;row_factory&#39;</span><span class="p">,</span> <span class="n">rf</span><span class="p">)</span>

    <span class="n">_default_timeout</span> <span class="o">=</span> <span class="mf">10.0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A default timeout, measured in seconds, for queries executed through</span>
<span class="sd">        :meth:`.execute()` or :meth:`.execute_async()`.  This default may be</span>
<span class="sd">        overridden with the `timeout` parameter for either of those methods.</span>

<span class="sd">        Setting this to :const:`None` will cause no timeouts to be set by default.</span>

<span class="sd">        Please see :meth:`.ResponseFuture.result` for details on the scope and</span>
<span class="sd">        effect of this timeout.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_timeout</span>

    <span class="nd">@default_timeout</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">default_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_set_legacy_config</span><span class="p">(</span><span class="s1">&#39;default_timeout&#39;</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>

    <span class="n">_default_consistency_level</span> <span class="o">=</span> <span class="n">ConsistencyLevel</span><span class="o">.</span><span class="n">LOCAL_ONE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_consistency_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The default :class:`~ConsistencyLevel` for operations executed through</span>
<span class="sd">        this session.  This default may be overridden by setting the</span>
<span class="sd">        :attr:`~.Statement.consistency_level` on individual statements.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">        .. versionchanged:: 3.0.0</span>

<span class="sd">            default changed from ONE to LOCAL_ONE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_consistency_level</span>

    <span class="nd">@default_consistency_level</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">default_consistency_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_set_legacy_config</span><span class="p">(</span><span class="s1">&#39;default_consistency_level&#39;</span><span class="p">,</span> <span class="n">cl</span><span class="p">)</span>

    <span class="n">_default_serial_consistency_level</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_serial_consistency_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The default :class:`~ConsistencyLevel` for serial phase of  conditional updates executed through</span>
<span class="sd">        this session.  This default may be overridden by setting the</span>
<span class="sd">        :attr:`~.Statement.serial_consistency_level` on individual statements.</span>

<span class="sd">        Only valid for ``protocol_version &gt;= 2``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_serial_consistency_level</span>

    <span class="nd">@default_serial_consistency_level</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">default_serial_consistency_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_set_legacy_config</span><span class="p">(</span><span class="s1">&#39;default_serial_consistency_level&#39;</span><span class="p">,</span> <span class="n">cl</span><span class="p">)</span>

    <span class="n">max_trace_wait</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The maximum amount of time (in seconds) the driver will wait for trace</span>
<span class="sd">    details to be populated server-side for a query before giving up.</span>
<span class="sd">    If the `trace` parameter for :meth:`~.execute()` or :meth:`~.execute_async()`</span>
<span class="sd">    is :const:`True`, the driver will repeatedly attempt to fetch trace</span>
<span class="sd">    details for the query (using exponential backoff) until this limit is</span>
<span class="sd">    hit.  If the limit is passed, an error will be logged and the</span>
<span class="sd">    :attr:`.Statement.trace` will be left as :const:`None`. &quot;&quot;&quot;</span>

    <span class="n">default_fetch_size</span> <span class="o">=</span> <span class="mi">5000</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    By default, this many rows will be fetched at a time. Setting</span>
<span class="sd">    this to :const:`None` will disable automatic paging for large query</span>
<span class="sd">    results.  The fetch size can be also specified per-query through</span>
<span class="sd">    :attr:`.Statement.fetch_size`.</span>

<span class="sd">    This only takes effect when protocol version 2 or higher is used.</span>
<span class="sd">    See :attr:`.Cluster.protocol_version` for details.</span>

<span class="sd">    .. versionadded:: 2.0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">use_client_timestamp</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When using protocol version 3 or higher, write timestamps may be supplied</span>
<span class="sd">    client-side at the protocol level.  (Normally they are generated</span>
<span class="sd">    server-side by the coordinator node.)  Note that timestamps specified</span>
<span class="sd">    within a CQL query will override this timestamp.</span>

<span class="sd">    .. versionadded:: 2.1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">timestamp_generator</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When :attr:`use_client_timestamp` is set, sessions call this object and use</span>
<span class="sd">    the result as the timestamp.  (Note that timestamps specified within a CQL</span>
<span class="sd">    query will override this timestamp.)  By default, a new</span>
<span class="sd">    :class:`~.MonotonicTimestampGenerator` is created for</span>
<span class="sd">    each :class:`Cluster` instance.</span>

<span class="sd">    Applications can set this value for custom timestamp behavior.  For</span>
<span class="sd">    example, an application could share a timestamp generator across</span>
<span class="sd">    :class:`Cluster` objects to guarantee that the application will use unique,</span>
<span class="sd">    increasing timestamps across clusters, or set it to to ``lambda:</span>
<span class="sd">    int(time.time() * 1e6)`` if losing records over clock inconsistencies is</span>
<span class="sd">    acceptable for the application. Custom :attr:`timestamp_generator` s should</span>
<span class="sd">    be callable, and calling them should return an integer representing seconds</span>
<span class="sd">    since some point in time, typically UNIX epoch.</span>

<span class="sd">    .. versionadded:: 3.8.0</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">encoder</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~cassandra.encoder.Encoder` instance that will be used when</span>
<span class="sd">    formatting query parameters for non-prepared statements.  This is not used</span>
<span class="sd">    for prepared statements (because prepared statements give the driver more</span>
<span class="sd">    information about what CQL types are expected, allowing it to accept a</span>
<span class="sd">    wider range of python types).</span>

<span class="sd">    The encoder uses a mapping from python types to encoder methods (for</span>
<span class="sd">    specific CQL types).  This mapping can be be modified by users as they see</span>
<span class="sd">    fit.  Methods of :class:`~cassandra.encoder.Encoder` should be used for mapping</span>
<span class="sd">    values if possible, because they take precautions to avoid injections and</span>
<span class="sd">    properly sanitize data.</span>

<span class="sd">    Example::</span>

<span class="sd">        cluster = Cluster()</span>
<span class="sd">        session = cluster.connect(&quot;mykeyspace&quot;)</span>
<span class="sd">        session.encoder.mapping[tuple] = session.encoder.cql_encode_tuple</span>

<span class="sd">        session.execute(&quot;CREATE TABLE mytable (k int PRIMARY KEY, col tuple&lt;int, ascii&gt;)&quot;)</span>
<span class="sd">        session.execute(&quot;INSERT INTO mytable (k, col) VALUES (%s, %s)&quot;, [0, (123, &#39;abc&#39;)])</span>

<span class="sd">    .. versionadded:: 2.1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">client_protocol_handler</span> <span class="o">=</span> <span class="n">ProtocolHandler</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specifies a protocol handler that will be used for client-initiated requests (i.e. no</span>
<span class="sd">    internal driver requests). This can be used to override or extend features such as</span>
<span class="sd">    message or type ser/des.</span>

<span class="sd">    The default pure python implementation is :class:`cassandra.protocol.ProtocolHandler`.</span>

<span class="sd">    When compiled with Cython, there are also built-in faster alternatives. See :ref:`faster_deser`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_lock</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_pools</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_profile_manager</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_metrics</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_request_init_callbacks</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">hosts</span><span class="p">,</span> <span class="n">keyspace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hosts</span> <span class="o">=</span> <span class="n">hosts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyspace</span> <span class="o">=</span> <span class="n">keyspace</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pools</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_profile_manager</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">profile_manager</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_init_callbacks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">protocol_version</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">Encoder</span><span class="p">()</span>

        <span class="c1"># create connection pools in parallel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_connect_futures</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="n">hosts</span><span class="p">:</span>
            <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_or_renew_pool</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">future</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initial_connect_futures</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>

        <span class="n">futures</span> <span class="o">=</span> <span class="n">wait_futures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_initial_connect_futures</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">FIRST_COMPLETED</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">futures</span><span class="o">.</span><span class="n">not_done</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">futures</span><span class="o">.</span><span class="n">done</span><span class="p">):</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="n">wait_futures</span><span class="p">(</span><span class="n">futures</span><span class="o">.</span><span class="n">not_done</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">FIRST_COMPLETED</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_connect_futures</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unable to connect to any servers&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyspace</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; using keyspace &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyspace</span>
            <span class="k">raise</span> <span class="n">NoHostAvailable</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">address</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hosts</span><span class="p">])</span>

<div class="viewcode-block" id="Session.execute"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Session.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">_NOT_SET</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">custom_payload</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">execution_profile</span><span class="o">=</span><span class="n">EXEC_PROFILE_DEFAULT</span><span class="p">,</span> <span class="n">paging_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the given query and synchronously wait for the response.</span>

<span class="sd">        If an error is encountered while executing the query, an Exception</span>
<span class="sd">        will be raised.</span>

<span class="sd">        `query` may be a query string or an instance of :class:`cassandra.query.Statement`.</span>

<span class="sd">        `parameters` may be a sequence or dict of parameters to bind.  If a</span>
<span class="sd">        sequence is used, ``%s`` should be used the placeholder for each</span>
<span class="sd">        argument.  If a dict is used, ``%(name)s`` style placeholders must</span>
<span class="sd">        be used.</span>

<span class="sd">        `timeout` should specify a floating-point timeout (in seconds) after</span>
<span class="sd">        which an :exc:`.OperationTimedOut` exception will be raised if the query</span>
<span class="sd">        has not completed.  If not set, the timeout defaults to</span>
<span class="sd">        :attr:`~.Session.default_timeout`.  If set to :const:`None`, there is</span>
<span class="sd">        no timeout. Please see :meth:`.ResponseFuture.result` for details on</span>
<span class="sd">        the scope and effect of this timeout.</span>

<span class="sd">        If `trace` is set to :const:`True`, the query will be sent with tracing enabled.</span>
<span class="sd">        The trace details can be obtained using the returned :class:`.ResultSet` object.</span>

<span class="sd">        `custom_payload` is a :ref:`custom_payload` dict to be passed to the server.</span>
<span class="sd">        If `query` is a Statement with its own custom_payload. The message payload</span>
<span class="sd">        will be a union of the two, with the values specified here taking precedence.</span>

<span class="sd">        `execution_profile` is the execution profile to use for this request. It can be a key to a profile configured</span>
<span class="sd">        via :meth:`Cluster.add_execution_profile` or an instance (from :meth:`Session.execution_profile_clone_update`,</span>
<span class="sd">        for example</span>

<span class="sd">        `paging_state` is an optional paging state, reused from a previous :class:`ResultSet`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_async</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">custom_payload</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">execution_profile</span><span class="p">,</span> <span class="n">paging_state</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span></div>

<div class="viewcode-block" id="Session.execute_async"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Session.execute_async">[docs]</a>    <span class="k">def</span> <span class="nf">execute_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">custom_payload</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">_NOT_SET</span><span class="p">,</span> <span class="n">execution_profile</span><span class="o">=</span><span class="n">EXEC_PROFILE_DEFAULT</span><span class="p">,</span> <span class="n">paging_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the given query and return a :class:`~.ResponseFuture` object</span>
<span class="sd">        which callbacks may be attached to for asynchronous response</span>
<span class="sd">        delivery.  You may also call :meth:`~.ResponseFuture.result()`</span>
<span class="sd">        on the :class:`.ResponseFuture` to synchronously block for results at</span>
<span class="sd">        any time.</span>

<span class="sd">        See :meth:`Session.execute` for parameter definitions.</span>

<span class="sd">        Example usage::</span>

<span class="sd">            &gt;&gt;&gt; session = cluster.connect()</span>
<span class="sd">            &gt;&gt;&gt; future = session.execute_async(&quot;SELECT * FROM mycf&quot;)</span>

<span class="sd">            &gt;&gt;&gt; def log_results(results):</span>
<span class="sd">            ...     for row in results:</span>
<span class="sd">            ...         log.info(&quot;Results: %s&quot;, row)</span>

<span class="sd">            &gt;&gt;&gt; def log_error(exc):</span>
<span class="sd">            &gt;&gt;&gt;     log.error(&quot;Operation failed: %s&quot;, exc)</span>

<span class="sd">            &gt;&gt;&gt; future.add_callbacks(log_results, log_error)</span>

<span class="sd">        Async execution with blocking wait for results::</span>

<span class="sd">            &gt;&gt;&gt; future = session.execute_async(&quot;SELECT * FROM mycf&quot;)</span>
<span class="sd">            &gt;&gt;&gt; # do other stuff...</span>

<span class="sd">            &gt;&gt;&gt; try:</span>
<span class="sd">            ...     results = future.result()</span>
<span class="sd">            ... except Exception:</span>
<span class="sd">            ...     log.exception(&quot;Operation failed:&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_response_future</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">custom_payload</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">execution_profile</span><span class="p">,</span> <span class="n">paging_state</span><span class="p">)</span>
        <span class="n">future</span><span class="o">.</span><span class="n">_protocol_handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_protocol_handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_request</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
        <span class="n">future</span><span class="o">.</span><span class="n">send_request</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">future</span></div>

    <span class="k">def</span> <span class="nf">_create_response_future</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">custom_payload</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">execution_profile</span><span class="o">=</span><span class="n">EXEC_PROFILE_DEFAULT</span><span class="p">,</span> <span class="n">paging_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the ResponseFuture before calling send_request() on it &quot;&quot;&quot;</span>

        <span class="n">prepared_statement</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">SimpleStatement</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">PreparedStatement</span><span class="p">):</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">==</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">LEGACY</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">execution_profile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">EXEC_PROFILE_DEFAULT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify execution_profile while using legacy parameters.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="n">_NOT_SET</span><span class="p">:</span>
                <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_timeout</span>

            <span class="n">cl</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">consistency_level</span> <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">consistency_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_consistency_level</span>
            <span class="n">serial_cl</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">serial_consistency_level</span> <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">serial_consistency_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_serial_consistency_level</span>

            <span class="n">retry_policy</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">retry_policy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">default_retry_policy</span>
            <span class="n">row_factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_factory</span>
            <span class="n">load_balancing_policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">load_balancing_policy</span>
            <span class="n">spec_exec_policy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">execution_profile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_execution_profile</span><span class="p">(</span><span class="n">execution_profile</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="n">_NOT_SET</span><span class="p">:</span>
                <span class="n">timeout</span> <span class="o">=</span> <span class="n">execution_profile</span><span class="o">.</span><span class="n">request_timeout</span>

            <span class="n">cl</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">consistency_level</span> <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">consistency_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">execution_profile</span><span class="o">.</span><span class="n">consistency_level</span>
            <span class="n">serial_cl</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">serial_consistency_level</span> <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">serial_consistency_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">execution_profile</span><span class="o">.</span><span class="n">serial_consistency_level</span>

            <span class="n">retry_policy</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">retry_policy</span> <span class="ow">or</span> <span class="n">execution_profile</span><span class="o">.</span><span class="n">retry_policy</span>
            <span class="n">row_factory</span> <span class="o">=</span> <span class="n">execution_profile</span><span class="o">.</span><span class="n">row_factory</span>
            <span class="n">load_balancing_policy</span> <span class="o">=</span> <span class="n">execution_profile</span><span class="o">.</span><span class="n">load_balancing_policy</span>
            <span class="n">spec_exec_policy</span> <span class="o">=</span> <span class="n">execution_profile</span><span class="o">.</span><span class="n">speculative_execution_policy</span>


        <span class="n">fetch_size</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">fetch_size</span>
        <span class="k">if</span> <span class="n">fetch_size</span> <span class="ow">is</span> <span class="n">FETCH_SIZE_UNSET</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fetch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_fetch_size</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fetch_size</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_client_timestamp</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">timestamp_generator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">SimpleStatement</span><span class="p">):</span>
            <span class="n">query_string</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">query_string</span>
            <span class="k">if</span> <span class="n">parameters</span><span class="p">:</span>
                <span class="n">query_string</span> <span class="o">=</span> <span class="n">bind_params</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">QueryMessage</span><span class="p">(</span>
                <span class="n">query_string</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">serial_cl</span><span class="p">,</span>
                <span class="n">fetch_size</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">BoundStatement</span><span class="p">):</span>
            <span class="n">prepared_statement</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">prepared_statement</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">ExecuteMessage</span><span class="p">(</span>
                <span class="n">prepared_statement</span><span class="o">.</span><span class="n">query_id</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span>
                <span class="n">serial_cl</span><span class="p">,</span> <span class="n">fetch_size</span><span class="p">,</span>
                <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">skip_meta</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">prepared_statement</span><span class="o">.</span><span class="n">result_metadata</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">BatchStatement</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span>
                    <span class="s2">&quot;BatchStatement execution is only supported with protocol version &quot;</span>
                    <span class="s2">&quot;2 or higher (supported in Cassandra 2.0 and higher).  Consider &quot;</span>
                    <span class="s2">&quot;setting Cluster.protocol_version to 2 to support this operation.&quot;</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">BatchMessage</span><span class="p">(</span>
                <span class="n">query</span><span class="o">.</span><span class="n">batch_type</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">_statements_and_parameters</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span>
                <span class="n">serial_cl</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">)</span>

        <span class="n">message</span><span class="o">.</span><span class="n">tracing</span> <span class="o">=</span> <span class="n">trace</span>

        <span class="n">message</span><span class="o">.</span><span class="n">update_custom_payload</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">custom_payload</span><span class="p">)</span>
        <span class="n">message</span><span class="o">.</span><span class="n">update_custom_payload</span><span class="p">(</span><span class="n">custom_payload</span><span class="p">)</span>
        <span class="n">message</span><span class="o">.</span><span class="n">allow_beta_protocol_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">allow_beta_protocol_version</span>
        <span class="n">message</span><span class="o">.</span><span class="n">paging_state</span> <span class="o">=</span> <span class="n">paging_state</span>

        <span class="n">spec_exec_plan</span> <span class="o">=</span> <span class="n">spec_exec_policy</span><span class="o">.</span><span class="n">new_plan</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">keyspace</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span> <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">is_idempotent</span> <span class="ow">and</span> <span class="n">spec_exec_policy</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">ResponseFuture</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="p">,</span>
            <span class="n">prepared_statement</span><span class="o">=</span><span class="n">prepared_statement</span><span class="p">,</span> <span class="n">retry_policy</span><span class="o">=</span><span class="n">retry_policy</span><span class="p">,</span> <span class="n">row_factory</span><span class="o">=</span><span class="n">row_factory</span><span class="p">,</span>
            <span class="n">load_balancer</span><span class="o">=</span><span class="n">load_balancing_policy</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">speculative_execution_plan</span><span class="o">=</span><span class="n">spec_exec_plan</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_execution_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep</span><span class="p">):</span>
        <span class="n">profiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">profiles</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ep</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ExecutionProfile</span><span class="p">)</span> <span class="k">else</span> <span class="n">profiles</span><span class="p">[</span><span class="n">ep</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid execution_profile: &#39;</span><span class="si">%s</span><span class="s2">&#39;; valid profiles are </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">profiles</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

<div class="viewcode-block" id="Session.execution_profile_clone_update"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Session.execution_profile_clone_update">[docs]</a>    <span class="k">def</span> <span class="nf">execution_profile_clone_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a clone of the ``ep`` profile.  ``kwargs`` can be specified to update attributes</span>
<span class="sd">        of the returned profile.</span>

<span class="sd">        This is a shallow clone, so any objects referenced by the profile are shared. This means Load Balancing Policy</span>
<span class="sd">        is maintained by inclusion in the active profiles. It also means updating any other rich objects will be seen</span>
<span class="sd">        by the active profile. In cases where this is not desirable, be sure to replace the instance instead of manipulating</span>
<span class="sd">        the shared object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_execution_profile</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">clone</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clone</span></div>

<div class="viewcode-block" id="Session.add_request_init_listener"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Session.add_request_init_listener">[docs]</a>    <span class="k">def</span> <span class="nf">add_request_init_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a callback with arguments to be called when any request is created.</span>

<span class="sd">        It will be invoked as `fn(response_future, *args, **kwargs)` after each client request is created,</span>
<span class="sd">        and before the request is sent\*. This can be used to create extensions by adding result callbacks to the</span>
<span class="sd">        response future.</span>

<span class="sd">        \* where `response_future` is the :class:`.ResponseFuture` for the request.</span>

<span class="sd">        Note that the init callback is done on the client thread creating the request, so you may need to consider</span>
<span class="sd">        synchronization if you have multiple threads. Any callbacks added to the response future will be executed</span>
<span class="sd">        on the event loop thread, so the normal advice about minimizing cycles and avoiding blocking apply (see Note in</span>
<span class="sd">        :meth:`.ResponseFuture.add_callbacks`.</span>

<span class="sd">        See `this example &lt;https://github.com/datastax/python-driver/blob/master/examples/request_init_listener.py&gt;`_ in the</span>
<span class="sd">        source tree for an example.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_init_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="Session.remove_request_init_listener"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Session.remove_request_init_listener">[docs]</a>    <span class="k">def</span> <span class="nf">remove_request_init_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a callback and arguments from the list.</span>

<span class="sd">        See :meth:`.Session.add_request_init_listener`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_request_init_callbacks</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_on_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response_future</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_request_init_callbacks</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="n">response_future</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Session.prepare"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Session.prepare">[docs]</a>    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">custom_payload</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepares a query string, returning a :class:`~cassandra.query.PreparedStatement`</span>
<span class="sd">        instance which can be used as follows::</span>

<span class="sd">            &gt;&gt;&gt; session = cluster.connect(&quot;mykeyspace&quot;)</span>
<span class="sd">            &gt;&gt;&gt; query = &quot;INSERT INTO users (id, name, age) VALUES (?, ?, ?)&quot;</span>
<span class="sd">            &gt;&gt;&gt; prepared = session.prepare(query)</span>
<span class="sd">            &gt;&gt;&gt; session.execute(prepared, (user.id, user.name, user.age))</span>

<span class="sd">        Or you may bind values to the prepared statement ahead of time::</span>

<span class="sd">            &gt;&gt;&gt; prepared = session.prepare(query)</span>
<span class="sd">            &gt;&gt;&gt; bound_stmt = prepared.bind((user.id, user.name, user.age))</span>
<span class="sd">            &gt;&gt;&gt; session.execute(bound_stmt)</span>

<span class="sd">        Of course, prepared statements may (and should) be reused::</span>

<span class="sd">            &gt;&gt;&gt; prepared = session.prepare(query)</span>
<span class="sd">            &gt;&gt;&gt; for user in users:</span>
<span class="sd">            ...     bound = prepared.bind((user.id, user.name, user.age))</span>
<span class="sd">            ...     session.execute(bound)</span>

<span class="sd">        **Important**: PreparedStatements should be prepared only once.</span>
<span class="sd">        Preparing the same query more than once will likely affect performance.</span>

<span class="sd">        `custom_payload` is a key value map to be passed along with the prepare</span>
<span class="sd">        message. See :ref:`custom_payload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">PrepareMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">)</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">ResponseFuture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_timeout</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">send_request</span><span class="p">()</span>
            <span class="n">query_id</span><span class="p">,</span> <span class="n">bind_metadata</span><span class="p">,</span> <span class="n">pk_indexes</span><span class="p">,</span> <span class="n">result_metadata</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Error preparing query:&quot;</span><span class="p">)</span>
            <span class="k">raise</span>

        <span class="n">prepared_statement</span> <span class="o">=</span> <span class="n">PreparedStatement</span><span class="o">.</span><span class="n">from_message</span><span class="p">(</span>
            <span class="n">query_id</span><span class="p">,</span> <span class="n">bind_metadata</span><span class="p">,</span> <span class="n">pk_indexes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyspace</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version</span><span class="p">,</span> <span class="n">result_metadata</span><span class="p">)</span>
        <span class="n">prepared_statement</span><span class="o">.</span><span class="n">custom_payload</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">custom_payload</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">add_prepared</span><span class="p">(</span><span class="n">query_id</span><span class="p">,</span> <span class="n">prepared_statement</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">prepare_on_all_hosts</span><span class="p">:</span>
            <span class="n">host</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">_current_host</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prepare_on_all_hosts</span><span class="p">(</span><span class="n">prepared_statement</span><span class="o">.</span><span class="n">query_string</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Error preparing query on all hosts:&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">prepared_statement</span></div>

    <span class="k">def</span> <span class="nf">prepare_on_all_hosts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">excluded_host</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare the given query on all hosts, excluding ``excluded_host``.</span>
<span class="sd">        Intended for internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">host</span> <span class="o">!=</span> <span class="n">excluded_host</span> <span class="ow">and</span> <span class="n">host</span><span class="o">.</span><span class="n">is_up</span><span class="p">:</span>
                <span class="n">future</span> <span class="o">=</span> <span class="n">ResponseFuture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PrepareMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_timeout</span><span class="p">)</span>

                <span class="c1"># we don&#39;t care about errors preparing against specific hosts,</span>
                <span class="c1"># since we can always prepare them as needed when the prepared</span>
                <span class="c1"># statement is used.  Just log errors and continue on.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">request_id</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Error preparing query for host </span><span class="si">%s</span><span class="s2">:&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">request_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># the error has already been logged by ResponsFuture</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Failed to prepare query for host </span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="n">host</span><span class="p">,</span> <span class="n">future</span><span class="o">.</span><span class="n">_errors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">host</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="n">future</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">host</span><span class="p">,</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Error preparing query for host </span><span class="si">%s</span><span class="s2">:&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

<div class="viewcode-block" id="Session.shutdown"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Session.shutdown">[docs]</a>    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close all connections.  ``Session`` instances should not be used</span>
<span class="sd">        for any purpose after being shutdown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># PYTHON-673. If shutdown was called shortly after session init, avoid</span>
        <span class="c1"># a race by cancelling any initial connection attempts haven&#39;t started,</span>
        <span class="c1"># then blocking on any that have.</span>
        <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_connect_futures</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
        <span class="n">wait_futures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_initial_connect_futures</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Ensure all connections are closed, in case the Session object is deleted by the GC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_or_renew_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile_manager</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">==</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">run_add_or_renew_pool</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">new_pool</span> <span class="o">=</span> <span class="n">HostConnection</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_pool</span> <span class="o">=</span> <span class="n">HostConnectionPool</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">AuthenticationFailed</span> <span class="k">as</span> <span class="n">auth_exc</span><span class="p">:</span>
                <span class="n">conn_exc</span> <span class="o">=</span> <span class="n">ConnectionException</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">auth_exc</span><span class="p">),</span> <span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">signal_connection_failure</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">conn_exc</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">conn_exc</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to create connection pool for new host </span><span class="si">%s</span><span class="s2">:&quot;</span><span class="p">,</span>
                            <span class="n">host</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">conn_exc</span><span class="p">)</span>
                <span class="c1"># the host itself will still be marked down, so we need to pass</span>
                <span class="c1"># a special flag to make sure the reconnector is created</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">signal_connection_failure</span><span class="p">(</span>
                    <span class="n">host</span><span class="p">,</span> <span class="n">conn_exc</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">,</span> <span class="n">expect_host_to_be_down</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">previous</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">new_pool</span><span class="o">.</span><span class="n">_keyspace</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyspace</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                    <span class="n">set_keyspace_event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
                    <span class="n">errors_returned</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">errors</span><span class="p">):</span>
                        <span class="n">errors_returned</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
                        <span class="n">set_keyspace_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

                    <span class="n">new_pool</span><span class="o">.</span><span class="n">_set_keyspace_for_all_conns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
                    <span class="n">set_keyspace_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">connect_timeout</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">set_keyspace_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="ow">or</span> <span class="n">errors_returned</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed setting keyspace for pool after keyspace changed during connect: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">errors_returned</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="p">)</span>
                        <span class="n">new_pool</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pool</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Added pool for host </span><span class="si">%s</span><span class="s2"> to session&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">previous</span><span class="p">:</span>
                <span class="n">previous</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">run_add_or_renew_pool</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Removed connection pool for </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">shutdown</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">update_created_pools</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When the set of live nodes change, the loadbalancer will change its</span>
<span class="sd">        mind on host distances. It might change it on the node that came/left</span>
<span class="sd">        but also on other nodes (for instance, if a node dies, another</span>
<span class="sd">        previously ignored node may be now considered).</span>

<span class="sd">        This method ensures that all hosts for which a pool should exist</span>
<span class="sd">        have one, and hosts that shouldn&#39;t don&#39;t.</span>

<span class="sd">        For internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">all_hosts</span><span class="p">():</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile_manager</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
            <span class="n">future</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pool</span> <span class="ow">or</span> <span class="n">pool</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
                <span class="c1"># we don&#39;t eagerly set is_up on previously ignored hosts. None is included here</span>
                <span class="c1"># to allow us to attempt connections to hosts that have gone from ignored to something</span>
                <span class="c1"># else.</span>
                <span class="k">if</span> <span class="n">distance</span> <span class="o">!=</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span> <span class="ow">and</span> <span class="n">host</span><span class="o">.</span><span class="n">is_up</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_or_renew_pool</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">distance</span> <span class="o">!=</span> <span class="n">pool</span><span class="o">.</span><span class="n">host_distance</span><span class="p">:</span>
                <span class="c1"># the distance has changed</span>
                <span class="k">if</span> <span class="n">distance</span> <span class="o">==</span> <span class="n">HostDistance</span><span class="o">.</span><span class="n">IGNORED</span><span class="p">:</span>
                    <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_pool</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pool</span><span class="o">.</span><span class="n">host_distance</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="k">if</span> <span class="n">future</span><span class="p">:</span>
                <span class="n">futures</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">futures</span>

    <span class="k">def</span> <span class="nf">on_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the parent Cluster instance when a node is marked down.</span>
<span class="sd">        Only intended for internal use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_pool</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">future</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_created_pools</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">on_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Internal &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>

<div class="viewcode-block" id="Session.set_keyspace"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.Session.set_keyspace">[docs]</a>    <span class="k">def</span> <span class="nf">set_keyspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the default keyspace for all queries made through this Session.</span>
<span class="sd">        This operation blocks until complete.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;USE </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">protect_name</span><span class="p">(</span><span class="n">keyspace</span><span class="p">),))</span></div>

    <span class="k">def</span> <span class="nf">_set_keyspace_for_all_pools</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Asynchronously sets the keyspace on all pools.  When all</span>
<span class="sd">        pools have set all of their connections, `callback` will be</span>
<span class="sd">        called with a dictionary of all errors that occurred, keyed</span>
<span class="sd">        by the `Host` that they occurred against.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyspace</span> <span class="o">=</span> <span class="n">keyspace</span>
            <span class="n">remaining_callbacks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">remaining_callbacks</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">pool_finished_setting_keyspace</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">host_errors</span><span class="p">):</span>
            <span class="n">remaining_callbacks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">host_errors</span><span class="p">:</span>
                <span class="n">errors</span><span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">host_errors</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">remaining_callbacks</span><span class="p">:</span>
                <span class="n">callback</span><span class="p">(</span><span class="n">host_errors</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">_set_keyspace_for_all_conns</span><span class="p">(</span><span class="n">keyspace</span><span class="p">,</span> <span class="n">pool_finished_setting_keyspace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">user_type_registered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">,</span> <span class="n">user_type</span><span class="p">,</span> <span class="n">klass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the parent Cluster instance when the user registers a new</span>
<span class="sd">        mapping from a user-defined type to a class.  Intended for internal</span>
<span class="sd">        use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ks_meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">keyspaces</span><span class="p">[</span><span class="n">keyspace</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UserTypeDoesNotExist</span><span class="p">(</span>
                <span class="s1">&#39;Keyspace </span><span class="si">%s</span><span class="s1"> does not exist or has not been discovered by the driver&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">keyspace</span><span class="p">,))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">type_meta</span> <span class="o">=</span> <span class="n">ks_meta</span><span class="o">.</span><span class="n">user_types</span><span class="p">[</span><span class="n">user_type</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UserTypeDoesNotExist</span><span class="p">(</span>
                <span class="s1">&#39;User type </span><span class="si">%s</span><span class="s1"> does not exist in keyspace </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">user_type</span><span class="p">,</span> <span class="n">keyspace</span><span class="p">))</span>

        <span class="n">field_names</span> <span class="o">=</span> <span class="n">type_meta</span><span class="o">.</span><span class="n">field_names</span>
        <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>
            <span class="c1"># go from unicode to string to avoid decode errors from implicit</span>
            <span class="c1"># decode when formatting non-ascii values</span>
            <span class="n">field_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;{ </span><span class="si">%s</span><span class="s1"> }&#39;</span> <span class="o">%</span> <span class="s1">&#39; , &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> : </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">field_name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">cql_encode_all_types</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">klass</span><span class="p">]</span> <span class="o">=</span> <span class="n">encode</span>

    <span class="k">def</span> <span class="nf">submit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Internal &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_pool_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="n">pool</span><span class="o">.</span><span class="n">get_state</span><span class="p">())</span> <span class="k">for</span> <span class="n">host</span><span class="p">,</span> <span class="n">pool</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">get_pools</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_validate_set_legacy_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">==</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">PROFILES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set Session.</span><span class="si">%s</span><span class="s2"> while using Configuration Profiles. Set this in a profile instead.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,))</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">_config_mode</span> <span class="o">=</span> <span class="n">_ConfigMode</span><span class="o">.</span><span class="n">LEGACY</span></div>


<div class="viewcode-block" id="UserTypeDoesNotExist"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.UserTypeDoesNotExist">[docs]</a><span class="k">class</span> <span class="nc">UserTypeDoesNotExist</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An attempt was made to use a user-defined type that does not exist.</span>

<span class="sd">    .. versionadded:: 2.1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="k">class</span> <span class="nc">_ControlReconnectionHandler</span><span class="p">(</span><span class="n">_ReconnectionHandler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">control_connection</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_ReconnectionHandler</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">control_connection</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">try_reconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">_reconnect_internal</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_reconnection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">_set_new_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">next_delay</span><span class="p">):</span>
        <span class="c1"># TODO only overridden to add logging, so add logging</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">AuthenticationFailed</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Error trying to reconnect control connection: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_watch_callback</span><span class="p">(</span><span class="n">obj_weakref</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A callback handler for the ControlConnection that tolerates</span>
<span class="sd">    weak references.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">obj_weakref</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_clear_watcher</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">expiring_weakref</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Called when the ControlConnection object is about to be finalized.</span>
<span class="sd">    This clears watchers on the underlying Connection object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">control_conn_disposed</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">ReferenceError</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ControlConnection</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_SELECT_PEERS</span> <span class="o">=</span> <span class="s2">&quot;SELECT * FROM system.peers&quot;</span>
    <span class="n">_SELECT_PEERS_NO_TOKENS</span> <span class="o">=</span> <span class="s2">&quot;SELECT peer, data_center, rack, rpc_address, release_version, schema_version FROM system.peers&quot;</span>
    <span class="n">_SELECT_LOCAL</span> <span class="o">=</span> <span class="s2">&quot;SELECT * FROM system.local WHERE key=&#39;local&#39;&quot;</span>
    <span class="n">_SELECT_LOCAL_NO_TOKENS</span> <span class="o">=</span> <span class="s2">&quot;SELECT cluster_name, data_center, rack, partitioner, release_version, schema_version FROM system.local WHERE key=&#39;local&#39;&quot;</span>

    <span class="n">_SELECT_SCHEMA_PEERS</span> <span class="o">=</span> <span class="s2">&quot;SELECT peer, rpc_address, schema_version FROM system.peers&quot;</span>
    <span class="n">_SELECT_SCHEMA_LOCAL</span> <span class="o">=</span> <span class="s2">&quot;SELECT schema_version FROM system.local WHERE key=&#39;local&#39;&quot;</span>

    <span class="n">_is_shutdown</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_timeout</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_protocol_version</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_schema_event_refresh_window</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_topology_event_refresh_window</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_status_event_refresh_window</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_schema_meta_enabled</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_token_meta_enabled</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># for testing purposes</span>
    <span class="n">_time</span> <span class="o">=</span> <span class="n">time</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span>
                 <span class="n">schema_event_refresh_window</span><span class="p">,</span>
                 <span class="n">topology_event_refresh_window</span><span class="p">,</span>
                 <span class="n">status_event_refresh_window</span><span class="p">,</span>
                 <span class="n">schema_meta_enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">token_meta_enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># use a weak reference to allow the Cluster instance to be GC&#39;ed (and</span>
        <span class="c1"># shutdown) since implementing __del__ disables the cycle detector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="n">timeout</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_schema_event_refresh_window</span> <span class="o">=</span> <span class="n">schema_event_refresh_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_topology_event_refresh_window</span> <span class="o">=</span> <span class="n">topology_event_refresh_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status_event_refresh_window</span> <span class="o">=</span> <span class="n">status_event_refresh_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_schema_meta_enabled</span> <span class="o">=</span> <span class="n">schema_meta_enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_token_meta_enabled</span> <span class="o">=</span> <span class="n">token_meta_enabled</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_schema_agreement_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_event_schedule_times</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_shutdown</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_protocol_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">protocol_version</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_new_connection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reconnect_internal</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_set_new_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace existing connection (if there is one) and close it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">conn</span>

        <span class="k">if</span> <span class="n">old</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Closing old connection </span><span class="si">%r</span><span class="s2">, replacing with </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
            <span class="n">old</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_reconnect_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tries to connect to each host in the query plan until one succeeds</span>
<span class="sd">        or every attempt fails. If successful, a new Connection will be</span>
<span class="sd">        returned.  Otherwise, :exc:`NoHostAvailable` will be raised</span>
<span class="sd">        with an &quot;errors&quot; arg that is a dict mapping host addresses</span>
<span class="sd">        to the exception that was raised when an attempt was made to open</span>
<span class="sd">        a connection to that host.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">_default_load_balancing_policy</span><span class="o">.</span><span class="n">make_query_plan</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_connect</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ConnectionException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">errors</span><span class="p">[</span><span class="n">host</span><span class="o">.</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;[control connection] Error connecting to </span><span class="si">%s</span><span class="s2">:&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">signal_connection_failure</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">errors</span><span class="p">[</span><span class="n">host</span><span class="o">.</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;[control connection] Error connecting to </span><span class="si">%s</span><span class="s2">:&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_shutdown</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;[control connection] Reconnection in progress during shutdown&quot;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="n">NoHostAvailable</span><span class="p">(</span><span class="s2">&quot;Unable to connect to any servers&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_try_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new Connection, registers for pushed events, and refreshes</span>
<span class="sd">        node/token and schema metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Opening new connection to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">connection_factory</span><span class="p">(</span><span class="n">host</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">is_control_connection</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_shutdown</span><span class="p">:</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                    <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;Reconnecting during shutdown&quot;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="n">ProtocolVersionUnsupported</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">protocol_downgrade</span><span class="p">(</span><span class="n">host</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">startup_version</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Established new connection </span><span class="si">%r</span><span class="s2">, &quot;</span>
                  <span class="s2">&quot;registering watchers and refreshing schema and topology&quot;</span><span class="p">,</span>
                  <span class="n">connection</span><span class="p">)</span>

        <span class="c1"># use weak references in both directions</span>
        <span class="c1"># _clear_watcher will be called when this ControlConnection is about to be finalized</span>
        <span class="c1"># _watch_callback will get the actual callback from the Connection and relay it to</span>
        <span class="c1"># this object (after a dereferencing a weakref)</span>
        <span class="n">self_weakref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">_clear_watcher</span><span class="p">,</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">connection</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">register_watchers</span><span class="p">({</span>
                <span class="s2">&quot;TOPOLOGY_CHANGE&quot;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">_watch_callback</span><span class="p">,</span> <span class="n">self_weakref</span><span class="p">,</span> <span class="s1">&#39;_handle_topology_change&#39;</span><span class="p">),</span>
                <span class="s2">&quot;STATUS_CHANGE&quot;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">_watch_callback</span><span class="p">,</span> <span class="n">self_weakref</span><span class="p">,</span> <span class="s1">&#39;_handle_status_change&#39;</span><span class="p">),</span>
                <span class="s2">&quot;SCHEMA_CHANGE&quot;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">_watch_callback</span><span class="p">,</span> <span class="n">self_weakref</span><span class="p">,</span> <span class="s1">&#39;_handle_schema_change&#39;</span><span class="p">)</span>
            <span class="p">},</span> <span class="n">register_timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span><span class="p">)</span>

            <span class="n">sel_peers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_PEERS</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_token_meta_enabled</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_PEERS_NO_TOKENS</span>
            <span class="n">sel_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_LOCAL</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_token_meta_enabled</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_LOCAL_NO_TOKENS</span>
            <span class="n">peers_query</span> <span class="o">=</span> <span class="n">QueryMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">sel_peers</span><span class="p">,</span> <span class="n">consistency_level</span><span class="o">=</span><span class="n">ConsistencyLevel</span><span class="o">.</span><span class="n">ONE</span><span class="p">)</span>
            <span class="n">local_query</span> <span class="o">=</span> <span class="n">QueryMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">sel_local</span><span class="p">,</span> <span class="n">consistency_level</span><span class="o">=</span><span class="n">ConsistencyLevel</span><span class="o">.</span><span class="n">ONE</span><span class="p">)</span>
            <span class="n">shared_results</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">wait_for_responses</span><span class="p">(</span>
                <span class="n">peers_query</span><span class="p">,</span> <span class="n">local_query</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_node_list_and_token_map</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">preloaded_results</span><span class="o">=</span><span class="n">shared_results</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_schema</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">preloaded_results</span><span class="o">=</span><span class="n">shared_results</span><span class="p">,</span> <span class="n">schema_agreement_wait</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span>

        <span class="k">return</span> <span class="n">connection</span>

    <span class="k">def</span> <span class="nf">reconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_shutdown</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_submit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reconnect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Attempting to reconnect&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_new_connection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reconnect_internal</span><span class="p">())</span>
        <span class="k">except</span> <span class="n">NoHostAvailable</span><span class="p">:</span>
            <span class="c1"># make a retry schedule (which includes backoff)</span>
            <span class="n">schedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">reconnection_policy</span><span class="o">.</span><span class="n">new_schedule</span><span class="p">()</span>

            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_lock</span><span class="p">:</span>

                <span class="c1"># cancel existing reconnection attempts</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

                <span class="c1"># when a connection is successfully made, _set_new_connection</span>
                <span class="c1"># will be called with the new connection and then our</span>
                <span class="c1"># _reconnection_handler will be cleared out</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span> <span class="o">=</span> <span class="n">_ControlReconnectionHandler</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_and_set_reconnection_handler</span><span class="p">,</span>
                    <span class="n">new_handler</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] error reconnecting&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">_get_and_set_reconnection_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_handler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the _ControlReconnectionHandler when a new connection</span>
<span class="sd">        is successfully created.  Clears out the _reconnection_handler on</span>
<span class="sd">        this ControlConnection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_lock</span><span class="p">:</span>
            <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span> <span class="o">=</span> <span class="n">new_handler</span>
            <span class="k">return</span> <span class="n">old</span>

    <span class="k">def</span> <span class="nf">_submit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ReferenceError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># stop trying to reconnect (if we are)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_shutdown</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_shutdown</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Shutting down control connection&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">refresh_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_schema</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ReferenceError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># our weak reference to the Cluster is no good</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Error refreshing schema&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_signal_error</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_refresh_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">preloaded_results</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">schema_agreement_wait</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">agreed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_schema_agreement</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span>
                                                <span class="n">preloaded_results</span><span class="o">=</span><span class="n">preloaded_results</span><span class="p">,</span>
                                                <span class="n">wait_time</span><span class="o">=</span><span class="n">schema_agreement_wait</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_meta_enabled</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Skipping schema refresh because schema metadata is disabled&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">agreed</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping schema refresh due to lack of schema agreement&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">refresh_node_list_and_token_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_token_rebuild</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_node_list_and_token_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">,</span> <span class="n">force_token_rebuild</span><span class="o">=</span><span class="n">force_token_rebuild</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">ReferenceError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># our weak reference to the Cluster is no good</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Error refreshing node list and token map&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_signal_error</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_refresh_node_list_and_token_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">preloaded_results</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">force_token_rebuild</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">preloaded_results</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Refreshing node list and token map using preloaded results&quot;</span><span class="p">)</span>
            <span class="n">peers_result</span> <span class="o">=</span> <span class="n">preloaded_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">local_result</span> <span class="o">=</span> <span class="n">preloaded_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cl</span> <span class="o">=</span> <span class="n">ConsistencyLevel</span><span class="o">.</span><span class="n">ONE</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_token_meta_enabled</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Refreshing node list without token map&quot;</span><span class="p">)</span>
                <span class="n">sel_peers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_PEERS_NO_TOKENS</span>
                <span class="n">sel_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_LOCAL_NO_TOKENS</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Refreshing node list and token map&quot;</span><span class="p">)</span>
                <span class="n">sel_peers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_PEERS</span>
                <span class="n">sel_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_LOCAL</span>
            <span class="n">peers_query</span> <span class="o">=</span> <span class="n">QueryMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">sel_peers</span><span class="p">,</span> <span class="n">consistency_level</span><span class="o">=</span><span class="n">cl</span><span class="p">)</span>
            <span class="n">local_query</span> <span class="o">=</span> <span class="n">QueryMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">sel_local</span><span class="p">,</span> <span class="n">consistency_level</span><span class="o">=</span><span class="n">cl</span><span class="p">)</span>
            <span class="n">peers_result</span><span class="p">,</span> <span class="n">local_result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">wait_for_responses</span><span class="p">(</span>
                <span class="n">peers_query</span><span class="p">,</span> <span class="n">local_query</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span><span class="p">)</span>

        <span class="n">peers_result</span> <span class="o">=</span> <span class="n">dict_factory</span><span class="p">(</span><span class="o">*</span><span class="n">peers_result</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

        <span class="n">partitioner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">token_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">found_hosts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">local_result</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
            <span class="n">found_hosts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">host</span><span class="p">)</span>
            <span class="n">local_rows</span> <span class="o">=</span> <span class="n">dict_factory</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">local_result</span><span class="o">.</span><span class="n">results</span><span class="p">))</span>
            <span class="n">local_row</span> <span class="o">=</span> <span class="n">local_rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cluster_name</span> <span class="o">=</span> <span class="n">local_row</span><span class="p">[</span><span class="s2">&quot;cluster_name&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">cluster_name</span> <span class="o">=</span> <span class="n">cluster_name</span>

            <span class="n">partitioner</span> <span class="o">=</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;partitioner&quot;</span><span class="p">)</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tokens&quot;</span><span class="p">)</span>

            <span class="n">host</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_host</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">host</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">host</span><span class="p">:</span>
                <span class="n">datacenter</span> <span class="o">=</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;data_center&quot;</span><span class="p">)</span>
                <span class="n">rack</span> <span class="o">=</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rack&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_location_info</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">datacenter</span><span class="p">,</span> <span class="n">rack</span><span class="p">)</span>
                <span class="n">host</span><span class="o">.</span><span class="n">listen_address</span> <span class="o">=</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;listen_address&quot;</span><span class="p">)</span>
                <span class="n">host</span><span class="o">.</span><span class="n">broadcast_address</span> <span class="o">=</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;broadcast_address&quot;</span><span class="p">)</span>
                <span class="n">host</span><span class="o">.</span><span class="n">release_version</span> <span class="o">=</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;release_version&quot;</span><span class="p">)</span>
                <span class="n">host</span><span class="o">.</span><span class="n">dse_version</span> <span class="o">=</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dse_version&quot;</span><span class="p">)</span>
                <span class="n">host</span><span class="o">.</span><span class="n">dse_workload</span> <span class="o">=</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;workload&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">partitioner</span> <span class="ow">and</span> <span class="n">tokens</span><span class="p">:</span>
                    <span class="n">token_map</span><span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span>

        <span class="c1"># Check metadata.partitioner to see if we haven&#39;t built anything yet. If</span>
        <span class="c1"># every node in the cluster was in the contact points, we won&#39;t discover</span>
        <span class="c1"># any new nodes, so we need this additional check.  (See PYTHON-90)</span>
        <span class="n">should_rebuild_token_map</span> <span class="o">=</span> <span class="n">force_token_rebuild</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">partitioner</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">peers_result</span><span class="p">:</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rpc_from_peer_row</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

            <span class="n">tokens</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tokens&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;tokens&#39;</span> <span class="ow">in</span> <span class="n">row</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tokens</span><span class="p">:</span>  <span class="c1"># it was selected, but empty</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Excluding host (</span><span class="si">%s</span><span class="s2">) with no tokens in system.peers table of </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">host</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">found_hosts</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Found multiple hosts with the same rpc_address (</span><span class="si">%s</span><span class="s2">). Excluding peer </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;peer&quot;</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="n">found_hosts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

            <span class="n">host</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_host</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
            <span class="n">datacenter</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;data_center&quot;</span><span class="p">)</span>
            <span class="n">rack</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rack&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">host</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Found new host to connect to: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
                <span class="n">host</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">add_host</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">datacenter</span><span class="p">,</span> <span class="n">rack</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">refresh_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">should_rebuild_token_map</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">should_rebuild_token_map</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_location_info</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">datacenter</span><span class="p">,</span> <span class="n">rack</span><span class="p">)</span>

            <span class="n">host</span><span class="o">.</span><span class="n">broadcast_address</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;peer&quot;</span><span class="p">)</span>
            <span class="n">host</span><span class="o">.</span><span class="n">release_version</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;release_version&quot;</span><span class="p">)</span>
            <span class="n">host</span><span class="o">.</span><span class="n">dse_version</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dse_version&quot;</span><span class="p">)</span>
            <span class="n">host</span><span class="o">.</span><span class="n">dse_workload</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;workload&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">partitioner</span> <span class="ow">and</span> <span class="n">tokens</span><span class="p">:</span>
                <span class="n">token_map</span><span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span>

        <span class="k">for</span> <span class="n">old_host</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">all_hosts</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">old_host</span><span class="o">.</span><span class="n">address</span> <span class="o">!=</span> <span class="n">connection</span><span class="o">.</span><span class="n">host</span> <span class="ow">and</span> <span class="n">old_host</span><span class="o">.</span><span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">found_hosts</span><span class="p">:</span>
                <span class="n">should_rebuild_token_map</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Removing host not found in peers metadata: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">old_host</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">remove_host</span><span class="p">(</span><span class="n">old_host</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Finished fetching ring info&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">partitioner</span> <span class="ow">and</span> <span class="n">should_rebuild_token_map</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Rebuilding token map due to topology changes&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">rebuild_token_map</span><span class="p">(</span><span class="n">partitioner</span><span class="p">,</span> <span class="n">token_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_location_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">datacenter</span><span class="p">,</span> <span class="n">rack</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">host</span><span class="o">.</span><span class="n">datacenter</span> <span class="o">==</span> <span class="n">datacenter</span> <span class="ow">and</span> <span class="n">host</span><span class="o">.</span><span class="n">rack</span> <span class="o">==</span> <span class="n">rack</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If the dc/rack information changes, we need to update the load balancing policy.</span>
        <span class="c1"># For that, we remove and re-add the node against the policy. Not the most elegant, and assumes</span>
        <span class="c1"># that the policy will update correctly, but in practice this should work.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="n">host</span><span class="o">.</span><span class="n">set_location_info</span><span class="p">(</span><span class="n">datacenter</span><span class="p">,</span> <span class="n">rack</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">profile_manager</span><span class="o">.</span><span class="n">on_up</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_delay_for_event_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">delay_window</span><span class="p">):</span>
        <span class="c1"># this serves to order processing correlated events (received within the window)</span>
        <span class="c1"># the window and randomization still have the desired effect of skew across client instances</span>
        <span class="n">next_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_schedule_times</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">event_type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">now</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">now</span> <span class="o">&lt;=</span> <span class="n">next_time</span><span class="p">:</span>
            <span class="n">this_time</span> <span class="o">=</span> <span class="n">next_time</span> <span class="o">+</span> <span class="mf">0.01</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="n">this_time</span> <span class="o">-</span> <span class="n">now</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="n">delay_window</span>
            <span class="n">this_time</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">delay</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_schedule_times</span><span class="p">[</span><span class="n">event_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_time</span>
        <span class="k">return</span> <span class="n">delay</span>

    <span class="k">def</span> <span class="nf">_refresh_nodes_if_not_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to mitigate refreshes for nodes that are already known.</span>
<span class="sd">        Some versions of the server send superfluous NEW_NODE messages in addition to UP events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">host</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_host</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">host</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">host</span><span class="o">.</span><span class="n">is_up</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refresh_node_list_and_token_map</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_handle_topology_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="n">change_type</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="s2">&quot;change_type&quot;</span><span class="p">]</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translate_address</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">change_type</span> <span class="o">==</span> <span class="s2">&quot;NEW_NODE&quot;</span> <span class="ow">or</span> <span class="n">change_type</span> <span class="o">==</span> <span class="s2">&quot;MOVED_NODE&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology_event_refresh_window</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_for_event_type</span><span class="p">(</span><span class="s1">&#39;topology_change&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology_event_refresh_window</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule_unique</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_nodes_if_not_up</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">change_type</span> <span class="o">==</span> <span class="s2">&quot;REMOVED_NODE&quot;</span><span class="p">:</span>
            <span class="n">host</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_host</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule_unique</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">remove_host</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_handle_status_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="n">change_type</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="s2">&quot;change_type&quot;</span><span class="p">]</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translate_address</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">host</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_host</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">change_type</span> <span class="o">==</span> <span class="s2">&quot;UP&quot;</span><span class="p">:</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_for_event_type</span><span class="p">(</span><span class="s1">&#39;status_change&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status_event_refresh_window</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">host</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># this is the first time we&#39;ve seen the node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule_unique</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">refresh_node_list_and_token_map</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule_unique</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">on_up</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">change_type</span> <span class="o">==</span> <span class="s2">&quot;DOWN&quot;</span><span class="p">:</span>
            <span class="c1"># Note that there is a slight risk we can receive the event late and thus</span>
            <span class="c1"># mark the host down even though we already had reconnected successfully.</span>
            <span class="c1"># But it is unlikely, and don&#39;t have too much consequence since we&#39;ll try reconnecting</span>
            <span class="c1"># right away, so we favor the detection to make the Host.is_up more accurate.</span>
            <span class="k">if</span> <span class="n">host</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># this will be run by the scheduler</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">on_down</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_translate_address</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">address_translator</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_handle_schema_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_event_refresh_window</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_for_event_type</span><span class="p">(</span><span class="s1">&#39;schema_change&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_event_refresh_window</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule_unique</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">refresh_schema</span><span class="p">,</span> <span class="o">**</span><span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wait_for_schema_agreement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preloaded_results</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wait_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">total_timeout</span> <span class="o">=</span> <span class="n">wait_time</span> <span class="k">if</span> <span class="n">wait_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">max_schema_agreement_wait</span>
        <span class="k">if</span> <span class="n">total_timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Each schema change typically generates two schema refreshes, one</span>
        <span class="c1"># from the response type and one from the pushed notification. Holding</span>
        <span class="c1"># a lock is just a simple way to cut down on the number of schema queries</span>
        <span class="c1"># we&#39;ll make.</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_agreement_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_shutdown</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">connection</span><span class="p">:</span>
                <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span>

            <span class="k">if</span> <span class="n">preloaded_results</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Attempting to use preloaded results for schema agreement&quot;</span><span class="p">)</span>

                <span class="n">peers_result</span> <span class="o">=</span> <span class="n">preloaded_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">local_result</span> <span class="o">=</span> <span class="n">preloaded_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">schema_mismatches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_schema_mismatches</span><span class="p">(</span><span class="n">peers_result</span><span class="p">,</span> <span class="n">local_result</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">host</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">schema_mismatches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Waiting for schema agreement&quot;</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">elapsed</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cl</span> <span class="o">=</span> <span class="n">ConsistencyLevel</span><span class="o">.</span><span class="n">ONE</span>
            <span class="n">schema_mismatches</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="n">elapsed</span> <span class="o">&lt;</span> <span class="n">total_timeout</span><span class="p">:</span>
                <span class="n">peers_query</span> <span class="o">=</span> <span class="n">QueryMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_SCHEMA_PEERS</span><span class="p">,</span> <span class="n">consistency_level</span><span class="o">=</span><span class="n">cl</span><span class="p">)</span>
                <span class="n">local_query</span> <span class="o">=</span> <span class="n">QueryMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_SELECT_SCHEMA_LOCAL</span><span class="p">,</span> <span class="n">consistency_level</span><span class="o">=</span><span class="n">cl</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">timeout</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span><span class="p">,</span> <span class="n">total_timeout</span> <span class="o">-</span> <span class="n">elapsed</span><span class="p">)</span>
                    <span class="n">peers_result</span><span class="p">,</span> <span class="n">local_result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">wait_for_responses</span><span class="p">(</span>
                        <span class="n">peers_query</span><span class="p">,</span> <span class="n">local_query</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">OperationTimedOut</span> <span class="k">as</span> <span class="n">timeout</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Timed out waiting for &quot;</span>
                              <span class="s2">&quot;response during schema agreement check: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
                    <span class="n">elapsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
                    <span class="k">continue</span>
                <span class="k">except</span> <span class="n">ConnectionShutdown</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_shutdown</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Aborting wait for schema match due to shutdown&quot;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span>

                <span class="n">schema_mismatches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_schema_mismatches</span><span class="p">(</span><span class="n">peers_result</span><span class="p">,</span> <span class="n">local_result</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">host</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">schema_mismatches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Schemas mismatched, trying again&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
                <span class="n">elapsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">%s</span><span class="s2"> is reporting a schema disagreement: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">connection</span><span class="o">.</span><span class="n">host</span><span class="p">,</span> <span class="n">schema_mismatches</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_schema_mismatches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peers_result</span><span class="p">,</span> <span class="n">local_result</span><span class="p">,</span> <span class="n">local_address</span><span class="p">):</span>
        <span class="n">peers_result</span> <span class="o">=</span> <span class="n">dict_factory</span><span class="p">(</span><span class="o">*</span><span class="n">peers_result</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>

        <span class="n">versions</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">local_result</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
            <span class="n">local_row</span> <span class="o">=</span> <span class="n">dict_factory</span><span class="p">(</span><span class="o">*</span><span class="n">local_result</span><span class="o">.</span><span class="n">results</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;schema_version&quot;</span><span class="p">):</span>
                <span class="n">versions</span><span class="p">[</span><span class="n">local_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;schema_version&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">local_address</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">peers_result</span><span class="p">:</span>
            <span class="n">schema_ver</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;schema_version&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">schema_ver</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rpc_from_peer_row</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">peer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_host</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">peer</span> <span class="ow">and</span> <span class="n">peer</span><span class="o">.</span><span class="n">is_up</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">versions</span><span class="p">[</span><span class="n">schema_ver</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">versions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Schemas match&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">version</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span> <span class="k">for</span> <span class="n">version</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">versions</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_rpc_from_peer_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rpc_address&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">addr</span> <span class="ow">or</span> <span class="n">addr</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="s2">&quot;::&quot;</span><span class="p">]:</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;peer&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translate_address</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_signal_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_shutdown</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="c1"># try just signaling the cluster, as this will trigger a reconnect</span>
            <span class="c1"># as part of marking the host down</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">is_defunct</span><span class="p">:</span>
                <span class="n">host</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_host</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">host</span><span class="p">)</span>
                <span class="c1"># host may be None if it&#39;s already been removed, but that indicates</span>
                <span class="c1"># that errors have already been reported, so we&#39;re fine</span>
                <span class="k">if</span> <span class="n">host</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">signal_connection_failure</span><span class="p">(</span>
                        <span class="n">host</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">last_error</span><span class="p">,</span> <span class="n">is_host_addition</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">return</span>

        <span class="c1"># if the connection is not defunct or the host already left, reconnect</span>
        <span class="c1"># manually</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconnect</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">on_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>

        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span>
        <span class="k">if</span> <span class="n">conn</span> <span class="ow">and</span> <span class="n">conn</span><span class="o">.</span><span class="n">host</span> <span class="o">==</span> <span class="n">host</span><span class="o">.</span><span class="n">address</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_reconnection_handler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Control connection host (</span><span class="si">%s</span><span class="s2">) is &quot;</span>
                      <span class="s2">&quot;considered down, starting reconnection&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="c1"># this will result in a task being submitted to the executor to reconnect</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reconnect</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">refresh_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">refresh_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refresh_node_list_and_token_map</span><span class="p">(</span><span class="n">force_token_rebuild</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">host</span> <span class="o">==</span> <span class="n">host</span><span class="o">.</span><span class="n">address</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[control connection] Control connection host (</span><span class="si">%s</span><span class="s2">) is being removed. Reconnecting&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="c1"># refresh will be done on reconnect</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reconnect</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refresh_node_list_and_token_map</span><span class="p">(</span><span class="n">force_token_rebuild</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_connection&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">return_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">connection</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="ow">and</span> <span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">is_defunct</span> <span class="ow">or</span> <span class="n">connection</span><span class="o">.</span><span class="n">is_closed</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reconnect</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_stop_scheduler</span><span class="p">(</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">thread</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="n">scheduler</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">ReferenceError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_Scheduler</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

    <span class="n">_queue</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_scheduled_tasks</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_executor</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">is_shutdown</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">executor</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="o">.</span><span class="n">PriorityQueue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scheduled_tasks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="o">=</span> <span class="n">executor</span>

        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Task Scheduler&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Shutting down Cluster Scheduler&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># this can happen on interpreter shutdown</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_insert_task</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

    <span class="k">def</span> <span class="nf">schedule_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">task</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scheduled_tasks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert_task</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Ignoring schedule_unique for already-scheduled task: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_insert_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="n">run_at</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">delay</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scheduled_tasks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">run_at</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">),</span> <span class="n">task</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Ignoring scheduled task after shutdown: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">run_at</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Not executing scheduled task due to Scheduler shutdown&quot;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">if</span> <span class="n">run_at</span> <span class="o">&lt;=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_scheduled_tasks</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                        <span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">task</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_if_failed</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">run_at</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span>
                        <span class="k">break</span>
            <span class="k">except</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_log_if_failed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="n">exc</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;An internally scheduled tasked failed with an unhandled exception:&quot;</span><span class="p">,</span>
                <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">refresh_schema_and_set_result</span><span class="p">(</span><span class="n">control_conn</span><span class="p">,</span> <span class="n">response_future</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Refreshing schema in response to schema change. &quot;</span>
                  <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">response_future</span><span class="o">.</span><span class="n">is_schema_agreed</span> <span class="o">=</span> <span class="n">control_conn</span><span class="o">.</span><span class="n">_refresh_schema</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Exception refreshing schema in response to schema change:&quot;</span><span class="p">)</span>
        <span class="n">response_future</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">control_conn</span><span class="o">.</span><span class="n">refresh_schema</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">response_future</span><span class="o">.</span><span class="n">_set_final_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>


<div class="viewcode-block" id="ResponseFuture"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResponseFuture">[docs]</a><span class="k">class</span> <span class="nc">ResponseFuture</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An asynchronous response delivery mechanism that is returned from calls</span>
<span class="sd">    to :meth:`.Session.execute_async()`.</span>

<span class="sd">    There are two ways for results to be delivered:</span>
<span class="sd">     - Synchronously, by calling :meth:`.result()`</span>
<span class="sd">     - Asynchronously, by attaching callback and errback functions via</span>
<span class="sd">       :meth:`.add_callback()`, :meth:`.add_errback()`, and</span>
<span class="sd">       :meth:`.add_callbacks()`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">query</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`~.Statement` instance that is being executed through this</span>
<span class="sd">    :class:`.ResponseFuture`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_schema_agreed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For DDL requests, this may be set ``False`` if the schema agreement poll after the response fails.</span>

<span class="sd">    Always ``True`` for non-DDL requests.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">request_encoded_size</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Size of the request message sent</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">coordinator_host</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The host from which we recieved a response</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attempted_hosts</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A list of hosts tried, including all speculative executions, retries, and pages</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">session</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">row_factory</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">message</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">default_timeout</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_retry_policy</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_profile_manager</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_req_id</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_final_result</span> <span class="o">=</span> <span class="n">_NOT_SET</span>
    <span class="n">_col_names</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_col_types</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_final_exception</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_query_traces</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_callbacks</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_errbacks</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_current_host</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_connection</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_query_retries</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">_start_time</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_metrics</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_paging_state</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_custom_payload</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_warnings</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_timer</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_protocol_handler</span> <span class="o">=</span> <span class="n">ProtocolHandler</span>
    <span class="n">_spec_execution_plan</span> <span class="o">=</span> <span class="n">NoSpeculativeExecutionPlan</span><span class="p">()</span>

    <span class="n">_warned_timeout</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepared_statement</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">retry_policy</span><span class="o">=</span><span class="n">RetryPolicy</span><span class="p">(),</span> <span class="n">row_factory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">load_balancer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">speculative_execution_plan</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>
        <span class="c1"># TODO: normalize handling of retry policy and row factory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">row_factory</span> <span class="ow">or</span> <span class="n">session</span><span class="o">.</span><span class="n">row_factory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_balancer</span> <span class="o">=</span> <span class="n">load_balancer</span> <span class="ow">or</span> <span class="n">session</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">_default_load_balancing_policy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_retry_policy</span> <span class="o">=</span> <span class="n">retry_policy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="o">=</span> <span class="n">metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepared_statement</span> <span class="o">=</span> <span class="n">prepared_statement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callback_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_time</span> <span class="o">=</span> <span class="n">start_time</span> <span class="ow">or</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_query_plan</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errbacks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spec_execution_plan</span> <span class="o">=</span> <span class="n">speculative_execution_plan</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec_execution_plan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attempted_hosts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_timer</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_time_remaining</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_start_timer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spec_delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spec_execution_plan</span><span class="o">.</span><span class="n">next_execution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_host</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">spec_delay</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_remaining</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_remaining</span> <span class="o">&gt;</span> <span class="n">spec_delay</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">connection_class</span><span class="o">.</span><span class="n">create_timer</span><span class="p">(</span><span class="n">spec_delay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_speculative_execute</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_remaining</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">connection_class</span><span class="o">.</span><span class="n">create_timer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_remaining</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_timeout</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cancel_timer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_on_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">errors</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_schema_agreed</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_host</span><span class="o">.</span><span class="n">address</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_host</span> <span class="k">else</span> <span class="s1">&#39;no host queried before timeout&#39;</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="s2">&quot;Client request timeout. See Session.execute[_async](timeout)&quot;</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">control_connection</span><span class="o">.</span><span class="n">_connection</span>
                <span class="n">host</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">host</span> <span class="k">if</span> <span class="n">connection</span> <span class="k">else</span> <span class="s1">&#39;unknown&#39;</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="n">host</span><span class="p">:</span> <span class="s2">&quot;Request timed out while waiting for schema agreement. See Session.execute[_async](timeout) and Cluster.max_schema_agreement_wait.&quot;</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">OperationTimedOut</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_host</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_on_speculative_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_remaining</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_on_timeout</span><span class="p">()</span>
                    <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span><span class="n">error_no_hosts</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start_timer</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_make_query_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># convert the list/generator/etc to an iterator so that subsequent</span>
        <span class="c1"># calls to send_request (which retries may do) will resume where</span>
        <span class="c1"># they last left off</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_plan</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load_balancer</span><span class="o">.</span><span class="n">make_query_plan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">keyspace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">send_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_no_hosts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Internal &quot;&quot;&quot;</span>
        <span class="c1"># query_plan is an iterator, so this will resume where we last left</span>
        <span class="c1"># off if send_request() is called multiple times</span>
        <span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_plan</span><span class="p">:</span>
            <span class="n">req_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">req_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_req_id</span> <span class="o">=</span> <span class="n">req_id</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_on_timeout</span><span class="p">()</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">error_no_hosts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">NoHostAvailable</span><span class="p">(</span>
                <span class="s2">&quot;Unable to complete the operation against any hosts&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cb</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span>

        <span class="n">pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_pools</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pool</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">ConnectionException</span><span class="p">(</span><span class="s2">&quot;Host has been marked down or removed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">pool</span><span class="o">.</span><span class="n">is_shutdown</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">ConnectionException</span><span class="p">(</span><span class="s2">&quot;Pool is shutdown&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_host</span> <span class="o">=</span> <span class="n">host</span>

        <span class="n">connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># TODO get connectTimeout from cluster settings</span>
            <span class="n">connection</span><span class="p">,</span> <span class="n">request_id</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">borrow_connection</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">connection</span>
            <span class="n">result_meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepared_statement</span><span class="o">.</span><span class="n">result_metadata</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepared_statement</span> <span class="k">else</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">cb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cb</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_result</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">request_encoded_size</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">request_id</span><span class="p">,</span> <span class="n">cb</span><span class="o">=</span><span class="n">cb</span><span class="p">,</span>
                                                            <span class="n">encoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_protocol_handler</span><span class="o">.</span><span class="n">encode_message</span><span class="p">,</span>
                                                            <span class="n">decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_protocol_handler</span><span class="o">.</span><span class="n">decode_message</span><span class="p">,</span>
                                                            <span class="n">result_metadata</span><span class="o">=</span><span class="n">result_meta</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attempted_hosts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">request_id</span>
        <span class="k">except</span> <span class="n">NoConnectionsAvailable</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;All connections for host </span><span class="si">%s</span><span class="s2"> are at capacity, moving to the next host&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Error querying host </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">on_connection_error</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">connection</span><span class="p">:</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">return_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_more_pages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns :const:`True` if there are more pages left in the</span>
<span class="sd">        query results, :const:`False` otherwise.  This should only</span>
<span class="sd">        be checked after the first page has been returned.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paging_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">warnings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Warnings returned from the server, if any. This will only be</span>
<span class="sd">        set for protocol_version 4+.</span>

<span class="sd">        Warnings may be returned for such things as oversized batches,</span>
<span class="sd">        or too many tombstones in slice queries.</span>

<span class="sd">        Ensure the future is complete before trying to access this property</span>
<span class="sd">        (call :meth:`.result()`, or after callback is invoked).</span>
<span class="sd">        Otherwise it may throw if the response has not been received.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: When timers are introduced, just make this wait</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;warnings cannot be retrieved before ResponseFuture is finalized&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warnings</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">custom_payload</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The custom payload returned from the server, if any. This will only be</span>
<span class="sd">        set by Cassandra servers implementing a custom QueryHandler, and only</span>
<span class="sd">        for protocol_version 4+.</span>

<span class="sd">        Ensure the future is complete before trying to access this property</span>
<span class="sd">        (call :meth:`.result()`, or after callback is invoked).</span>
<span class="sd">        Otherwise it may throw if the response has not been received.</span>

<span class="sd">        :return: :ref:`custom_payload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: When timers are introduced, just make this wait</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">DriverException</span><span class="p">(</span><span class="s2">&quot;custom_payload cannot be retrieved before ResponseFuture is finalized&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_custom_payload</span>

<div class="viewcode-block" id="ResponseFuture.start_fetching_next_page"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResponseFuture.start_fetching_next_page">[docs]</a>    <span class="k">def</span> <span class="nf">start_fetching_next_page</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If there are more pages left in the query result, this asynchronously</span>
<span class="sd">        starts fetching the next page.  If there are no pages left, :exc:`.QueryExhausted`</span>
<span class="sd">        is raised.  Also see :attr:`.has_more_pages`.</span>

<span class="sd">        This should only be called after the first page has been returned.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paging_state</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">QueryExhausted</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_make_query_plan</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">paging_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paging_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_final_result</span> <span class="o">=</span> <span class="n">_NOT_SET</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_timer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_reprepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prepare_message</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">submit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_after_prepare</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>
        <span class="n">request_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">prepare_message</span><span class="p">,</span> <span class="n">cb</span><span class="o">=</span><span class="n">cb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">request_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># try to submit the original prepared statement on some other host</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinator_host</span> <span class="o">=</span> <span class="n">host</span>
            <span class="k">if</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">return_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>

            <span class="n">trace_id</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s1">&#39;trace_id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trace_id</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_traces</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_query_traces</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">QueryTrace</span><span class="p">(</span><span class="n">trace_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_warnings</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s1">&#39;warnings&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_custom_payload</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s1">&#39;custom_payload&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">ResultMessage</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">RESULT_KIND_SET_KEYSPACE</span><span class="p">:</span>
                    <span class="n">session</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="c1"># since we&#39;re running on the event loop thread, we need to</span>
                    <span class="c1"># use a non-blocking method for setting the keyspace on</span>
                    <span class="c1"># all connections in this session, otherwise the event</span>
                    <span class="c1"># loop thread will deadlock waiting for keyspaces to be</span>
                    <span class="c1"># set.  This uses a callback chain which ends with</span>
                    <span class="c1"># self._set_keyspace_completed() being called in the</span>
                    <span class="c1"># event loop thread.</span>
                    <span class="k">if</span> <span class="n">session</span><span class="p">:</span>
                        <span class="n">session</span><span class="o">.</span><span class="n">_set_keyspace_for_all_pools</span><span class="p">(</span>
                            <span class="n">response</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_keyspace_completed</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">response</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">RESULT_KIND_SCHEMA_CHANGE</span><span class="p">:</span>
                    <span class="c1"># refresh the schema before responding, but do it in another</span>
                    <span class="c1"># thread instead of the event loop thread</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">is_schema_agreed</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                        <span class="n">refresh_schema_and_set_result</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">control_connection</span><span class="p">,</span>
                        <span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="o">**</span><span class="n">response</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s1">&#39;results&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">response</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">RESULT_KIND_ROWS</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_paging_state</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">paging_state</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_col_types</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">col_types</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_col_names</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_factory</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_result</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">ErrorMessage</span><span class="p">):</span>
                <span class="n">retry_policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retry_policy</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">ReadTimeoutErrorMessage</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">on_read_timeout</span><span class="p">()</span>
                    <span class="n">retry</span> <span class="o">=</span> <span class="n">retry_policy</span><span class="o">.</span><span class="n">on_read_timeout</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">,</span> <span class="n">retry_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_query_retries</span><span class="p">,</span> <span class="o">**</span><span class="n">response</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">WriteTimeoutErrorMessage</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">on_write_timeout</span><span class="p">()</span>
                    <span class="n">retry</span> <span class="o">=</span> <span class="n">retry_policy</span><span class="o">.</span><span class="n">on_write_timeout</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">,</span> <span class="n">retry_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_query_retries</span><span class="p">,</span> <span class="o">**</span><span class="n">response</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">UnavailableErrorMessage</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">on_unavailable</span><span class="p">()</span>
                    <span class="n">retry</span> <span class="o">=</span> <span class="n">retry_policy</span><span class="o">.</span><span class="n">on_unavailable</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">,</span> <span class="n">retry_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_query_retries</span><span class="p">,</span> <span class="o">**</span><span class="n">response</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">OverloadedErrorMessage</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">on_other_error</span><span class="p">()</span>
                    <span class="c1"># need to retry against a different host here</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Host </span><span class="si">%s</span><span class="s2"> is overloaded, retrying against a different &quot;</span>
                                <span class="s2">&quot;host&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_retry</span><span class="p">(</span><span class="n">reuse_connection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">consistency_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">IsBootstrappingErrorMessage</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">on_other_error</span><span class="p">()</span>
                    <span class="c1"># need to retry against a different host here</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_retry</span><span class="p">(</span><span class="n">reuse_connection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">consistency_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">PreparedQueryNotFound</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepared_statement</span><span class="p">:</span>
                        <span class="n">query_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepared_statement</span><span class="o">.</span><span class="n">query_id</span>
                        <span class="k">assert</span> <span class="n">query_id</span> <span class="o">==</span> <span class="n">response</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> \
                            <span class="s2">&quot;Got different query ID in server response (</span><span class="si">%s</span><span class="s2">) than we &quot;</span> \
                            <span class="s2">&quot;had before (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">query_id</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">query_id</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">info</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">prepared_statement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">_prepared_statements</span><span class="p">[</span><span class="n">query_id</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepared_statement</span><span class="p">:</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Tried to execute unknown prepared statement: id=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                      <span class="n">query_id</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">))</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">prepared_statement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepared_statement</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">_prepared_statements</span><span class="p">[</span><span class="n">query_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">prepared_statement</span>

                    <span class="n">current_keyspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">keyspace</span>
                    <span class="n">prepared_keyspace</span> <span class="o">=</span> <span class="n">prepared_statement</span><span class="o">.</span><span class="n">keyspace</span>
                    <span class="k">if</span> <span class="n">prepared_keyspace</span> <span class="ow">and</span> <span class="n">current_keyspace</span> <span class="o">!=</span> <span class="n">prepared_keyspace</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span>
                            <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Session&#39;s current keyspace (</span><span class="si">%s</span><span class="s2">) does &quot;</span>
                                       <span class="s2">&quot;not match the keyspace the statement was &quot;</span>
                                       <span class="s2">&quot;prepared with (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                       <span class="p">(</span><span class="n">current_keyspace</span><span class="p">,</span> <span class="n">prepared_keyspace</span><span class="p">)))</span>
                        <span class="k">return</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Re-preparing unrecognized prepared statement against host </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="n">host</span><span class="p">,</span> <span class="n">prepared_statement</span><span class="o">.</span><span class="n">query_string</span><span class="p">)</span>
                    <span class="n">prepare_message</span> <span class="o">=</span> <span class="n">PrepareMessage</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">prepared_statement</span><span class="o">.</span><span class="n">query_string</span><span class="p">)</span>
                    <span class="c1"># since this might block, run on the executor to avoid hanging</span>
                    <span class="c1"># the event loop thread</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reprepare</span><span class="p">,</span> <span class="n">prepare_message</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s1">&#39;to_exception&#39;</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">to_exception</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
                    <span class="k">return</span>

                <span class="n">retry_type</span><span class="p">,</span> <span class="n">consistency</span> <span class="o">=</span> <span class="n">retry</span>
                <span class="k">if</span> <span class="n">retry_type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">RetryPolicy</span><span class="o">.</span><span class="n">RETRY</span><span class="p">,</span> <span class="n">RetryPolicy</span><span class="o">.</span><span class="n">RETRY_NEXT_HOST</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_query_retries</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">reuse</span> <span class="o">=</span> <span class="n">retry_type</span> <span class="o">==</span> <span class="n">RetryPolicy</span><span class="o">.</span><span class="n">RETRY</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_retry</span><span class="p">(</span><span class="n">reuse</span><span class="p">,</span> <span class="n">consistency</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">retry_type</span> <span class="ow">is</span> <span class="n">RetryPolicy</span><span class="o">.</span><span class="n">RETHROW</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">to_exception</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># IGNORE</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">on_ignore</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">to_exception</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">ConnectionException</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">on_connection_error</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">ConnectionShutdown</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">defunct</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_retry</span><span class="p">(</span><span class="n">reuse_connection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">consistency_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s1">&#39;to_exception&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">to_exception</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we got some other kind of response message</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Got unexpected message: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">response</span><span class="p">,)</span>
                <span class="n">exc</span> <span class="o">=</span> <span class="n">ConnectionException</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cancel_timer</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">defunct</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># almost certainly caused by a bug, but we need to set something here</span>
            <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Unexpected exception while handling result in ResponseFuture:&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_keyspace_completed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errors</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">errors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">ConnectionException</span><span class="p">(</span>
                <span class="s2">&quot;Failed to set keyspace on all hosts: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">errors</span><span class="p">,)))</span>

    <span class="k">def</span> <span class="nf">_execute_after_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handle the response to our attempt to prepare a statement.</span>
<span class="sd">        If it succeeded, run the original query again against the same host.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">return_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">ResultMessage</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">RESULT_KIND_PREPARED</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepared_statement</span><span class="p">:</span>
                    <span class="c1"># result metadata is the only thing that could have</span>
                    <span class="c1"># changed from an alter</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">result_metadata</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">results</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prepared_statement</span><span class="o">.</span><span class="n">result_metadata</span> <span class="o">=</span> <span class="n">result_metadata</span>

                <span class="c1"># use self._query to re-use the same host and</span>
                <span class="c1"># at the same time properly borrow the connection</span>
                <span class="n">request_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">request_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># this host errored out, move on to the next</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">ConnectionException</span><span class="p">(</span>
                    <span class="s2">&quot;Got unexpected response when preparing statement &quot;</span>
                    <span class="s2">&quot;on host </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">response</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">ErrorMessage</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s1">&#39;to_exception&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">to_exception</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">ConnectionException</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Connection error when preparing statement on host </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                      <span class="n">host</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
            <span class="c1"># try again on a different host, preparing again if necessary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_final_exception</span><span class="p">(</span><span class="n">ConnectionException</span><span class="p">(</span>
                <span class="s2">&quot;Got unexpected response type when preparing &quot;</span>
                <span class="s2">&quot;statement on host </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">response</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_set_final_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cancel_timer</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">request_timer</span><span class="o">.</span><span class="n">addValue</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_time</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callback_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_final_result</span> <span class="o">=</span> <span class="n">response</span>
            <span class="c1"># save off current callbacks inside lock for execution outside it</span>
            <span class="c1"># -- prevents case where _final_result is set, then a callback is</span>
            <span class="c1"># added and executed on the spot, then executed again as a</span>
            <span class="c1"># registered callback</span>
            <span class="n">to_call</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">partial</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

        <span class="c1"># apply each callback</span>
        <span class="k">for</span> <span class="n">callback_partial</span> <span class="ow">in</span> <span class="n">to_call</span><span class="p">:</span>
            <span class="n">callback_partial</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_final_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cancel_timer</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">request_timer</span><span class="o">.</span><span class="n">addValue</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_time</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callback_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span> <span class="o">=</span> <span class="n">response</span>
            <span class="c1"># save off current errbacks inside lock for execution outside it --</span>
            <span class="c1"># prevents case where _final_exception is set, then an errback is</span>
            <span class="c1"># added and executed on the spot, then executed again as a</span>
            <span class="c1"># registered errback</span>
            <span class="n">to_call</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">partial</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errbacks</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

        <span class="c1"># apply each callback</span>
        <span class="k">for</span> <span class="n">callback_partial</span> <span class="ow">in</span> <span class="n">to_call</span><span class="p">:</span>
            <span class="n">callback_partial</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_retry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reuse_connection</span><span class="p">,</span> <span class="n">consistency_level</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span><span class="p">:</span>
            <span class="c1"># the connection probably broke while we were waiting</span>
            <span class="c1"># to retry the operation</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">on_retry</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">consistency_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">consistency_level</span> <span class="o">=</span> <span class="n">consistency_level</span>

        <span class="c1"># don&#39;t retry on the event loop thread</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_retry_task</span><span class="p">,</span> <span class="n">reuse_connection</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_retry_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reuse_connection</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span><span class="p">:</span>
            <span class="c1"># the connection probably broke while we were waiting</span>
            <span class="c1"># to retry the operation</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">reuse_connection</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># otherwise, move onto another host</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">()</span>

<div class="viewcode-block" id="ResponseFuture.result"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResponseFuture.result">[docs]</a>    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the final result or raise an Exception if errors were</span>
<span class="sd">        encountered.  If the final result or error has not been set</span>
<span class="sd">        yet, this method will block until it is set, or the timeout</span>
<span class="sd">        set for the request expires.</span>

<span class="sd">        Timeout is specified in the Session request execution functions.</span>
<span class="sd">        If the timeout is exceeded, an :exc:`cassandra.OperationTimedOut` will be raised.</span>
<span class="sd">        This is a client-side timeout. For more information</span>
<span class="sd">        about server-side coordinator timeouts, see :class:`.policies.RetryPolicy`.</span>

<span class="sd">        Example usage::</span>

<span class="sd">            &gt;&gt;&gt; future = session.execute_async(&quot;SELECT * FROM mycf&quot;)</span>
<span class="sd">            &gt;&gt;&gt; # do other stuff...</span>

<span class="sd">            &gt;&gt;&gt; try:</span>
<span class="sd">            ...     rows = future.result()</span>
<span class="sd">            ...     for row in rows:</span>
<span class="sd">            ...         ... # process results</span>
<span class="sd">            ... except Exception:</span>
<span class="sd">            ...     log.exception(&quot;Operation failed:&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_NOT_SET</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ResultSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span></div>

    <span class="k">def</span> <span class="nf">get_query_trace_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the trace session ids for this future, if tracing was enabled (does not fetch trace data).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">trace_id</span> <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_traces</span><span class="p">]</span>

<div class="viewcode-block" id="ResponseFuture.get_query_trace"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResponseFuture.get_query_trace">[docs]</a>    <span class="k">def</span> <span class="nf">get_query_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_wait</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">query_cl</span><span class="o">=</span><span class="n">ConsistencyLevel</span><span class="o">.</span><span class="n">LOCAL_ONE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches and returns the query trace of the last response, or `None` if tracing was</span>
<span class="sd">        not enabled.</span>

<span class="sd">        Note that this may raise an exception if there are problems retrieving the trace</span>
<span class="sd">        details from Cassandra. If the trace is not available after `max_wait`,</span>
<span class="sd">        :exc:`cassandra.query.TraceUnavailable` will be raised.</span>

<span class="sd">        If the ResponseFuture is not done (async execution) and you try to retrieve the trace,</span>
<span class="sd">        :exc:`cassandra.query.TraceUnavailable` will be raised.</span>

<span class="sd">        `query_cl` is the consistency level used to poll the trace tables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_result</span> <span class="ow">is</span> <span class="n">_NOT_SET</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TraceUnavailable</span><span class="p">(</span>
                <span class="s2">&quot;Trace information was not available. The ResponseFuture is not done.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_traces</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_query_trace</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_query_traces</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_wait</span><span class="p">,</span> <span class="n">query_cl</span><span class="p">)</span></div>

<div class="viewcode-block" id="ResponseFuture.get_all_query_traces"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResponseFuture.get_all_query_traces">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_query_traces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_wait_per</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">query_cl</span><span class="o">=</span><span class="n">ConsistencyLevel</span><span class="o">.</span><span class="n">LOCAL_ONE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches and returns the query traces for all query pages, if tracing was enabled.</span>

<span class="sd">        See note in :meth:`~.get_query_trace` regarding possible exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_traces</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_query_trace</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">max_wait_per</span><span class="p">,</span> <span class="n">query_cl</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_query_traces</span><span class="p">))]</span>
        <span class="k">return</span> <span class="p">[]</span></div>

    <span class="k">def</span> <span class="nf">_get_query_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">max_wait</span><span class="p">,</span> <span class="n">query_cl</span><span class="p">):</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_traces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trace</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="n">max_wait</span><span class="o">=</span><span class="n">max_wait</span><span class="p">,</span> <span class="n">query_cl</span><span class="o">=</span><span class="n">query_cl</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trace</span>

<div class="viewcode-block" id="ResponseFuture.add_callback"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResponseFuture.add_callback">[docs]</a>    <span class="k">def</span> <span class="nf">add_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attaches a callback function to be called when the final results arrive.</span>

<span class="sd">        By default, `fn` will be called with the results as the first and only</span>
<span class="sd">        argument.  If `*args` or `**kwargs` are supplied, they will be passed</span>
<span class="sd">        through as additional positional or keyword arguments to `fn`.</span>

<span class="sd">        If an error is hit while executing the operation, a callback attached</span>
<span class="sd">        here will not be called.  Use :meth:`.add_errback()` or :meth:`add_callbacks()`</span>
<span class="sd">        if you wish to handle that case.</span>

<span class="sd">        If the final result has already been seen when this method is called,</span>
<span class="sd">        the callback will be called immediately (before this method returns).</span>

<span class="sd">        Note: in the case that the result is not available when the callback is added,</span>
<span class="sd">        the callback is executed by IO event thread. This means that the callback</span>
<span class="sd">        should not block or attempt further synchronous requests, because no further</span>
<span class="sd">        IO will be processed until the callback returns.</span>

<span class="sd">        **Important**: if the callback you attach results in an exception being</span>
<span class="sd">        raised, **the exception will be ignored**, so please ensure your</span>
<span class="sd">        callback handles all error cases that you care about.</span>

<span class="sd">        Usage example::</span>

<span class="sd">            &gt;&gt;&gt; session = cluster.connect(&quot;mykeyspace&quot;)</span>

<span class="sd">            &gt;&gt;&gt; def handle_results(rows, start_time, should_log=False):</span>
<span class="sd">            ...     if should_log:</span>
<span class="sd">            ...         log.info(&quot;Total time: %f&quot;, time.time() - start_time)</span>
<span class="sd">            ...     ...</span>

<span class="sd">            &gt;&gt;&gt; future = session.execute_async(&quot;SELECT * FROM users&quot;)</span>
<span class="sd">            &gt;&gt;&gt; future.add_callback(handle_results, time.time(), should_log=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">run_now</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callback_lock</span><span class="p">:</span>
            <span class="c1"># Always add fn to self._callbacks, even when we&#39;re about to</span>
            <span class="c1"># execute it, to prevent races with functions like</span>
            <span class="c1"># start_fetching_next_page that reset _final_result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_NOT_SET</span><span class="p">:</span>
                <span class="n">run_now</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">run_now</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_final_result</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ResponseFuture.add_errback"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResponseFuture.add_errback">[docs]</a>    <span class="k">def</span> <span class="nf">add_errback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like :meth:`.add_callback()`, but handles error cases.</span>
<span class="sd">        An Exception instance will be passed as the first positional argument</span>
<span class="sd">        to `fn`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">run_now</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callback_lock</span><span class="p">:</span>
            <span class="c1"># Always add fn to self._errbacks, even when we&#39;re about to execute</span>
            <span class="c1"># it, to prevent races with functions like start_fetching_next_page</span>
            <span class="c1"># that reset _final_exception</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errbacks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span><span class="p">:</span>
                <span class="n">run_now</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">run_now</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ResponseFuture.add_callbacks"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResponseFuture.add_callbacks">[docs]</a>    <span class="k">def</span> <span class="nf">add_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">errback</span><span class="p">,</span>
                      <span class="n">callback_args</span><span class="o">=</span><span class="p">(),</span> <span class="n">callback_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">errback_args</span><span class="o">=</span><span class="p">(),</span> <span class="n">errback_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A convenient combination of :meth:`.add_callback()` and</span>
<span class="sd">        :meth:`.add_errback()`.</span>

<span class="sd">        Example usage::</span>

<span class="sd">            &gt;&gt;&gt; session = cluster.connect()</span>
<span class="sd">            &gt;&gt;&gt; query = &quot;SELECT * FROM mycf&quot;</span>
<span class="sd">            &gt;&gt;&gt; future = session.execute_async(query)</span>

<span class="sd">            &gt;&gt;&gt; def log_results(results, level=&#39;debug&#39;):</span>
<span class="sd">            ...     for row in results:</span>
<span class="sd">            ...         log.log(level, &quot;Result: %s&quot;, row)</span>

<span class="sd">            &gt;&gt;&gt; def log_error(exc, query):</span>
<span class="sd">            ...     log.error(&quot;Query &#39;%s&#39; failed: %s&quot;, query, exc)</span>

<span class="sd">            &gt;&gt;&gt; future.add_callbacks(</span>
<span class="sd">            ...     callback=log_results, callback_kwargs={&#39;level&#39;: &#39;info&#39;},</span>
<span class="sd">            ...     errback=log_error, errback_args=(query,))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">callback_args</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">callback_kwargs</span> <span class="ow">or</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_errback</span><span class="p">(</span><span class="n">errback</span><span class="p">,</span> <span class="o">*</span><span class="n">errback_args</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">errback_kwargs</span> <span class="ow">or</span> <span class="p">{}))</span></div>

    <span class="k">def</span> <span class="nf">clear_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callback_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errbacks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;(no result yet)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_result</span> <span class="ow">is</span> <span class="n">_NOT_SET</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_result</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;ResponseFuture: query=&#39;</span><span class="si">%s</span><span class="s2">&#39; request_id=</span><span class="si">%s</span><span class="s2"> result=</span><span class="si">%s</span><span class="s2"> exception=</span><span class="si">%s</span><span class="s2"> coordinator_host=</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> \
               <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_req_id</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_exception</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinator_host</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span></div>


<div class="viewcode-block" id="QueryExhausted"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.QueryExhausted">[docs]</a><span class="k">class</span> <span class="nc">QueryExhausted</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raised when :meth:`.ResponseFuture.start_fetching_next_page()` is called and</span>
<span class="sd">    there are no more pages.  You can check :attr:`.ResponseFuture.has_more_pages`</span>
<span class="sd">    before calling to avoid this.</span>

<span class="sd">    .. versionadded:: 2.0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ResultSet"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResultSet">[docs]</a><span class="k">class</span> <span class="nc">ResultSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An iterator over the rows from a query result. Also supplies basic equality</span>
<span class="sd">    and indexing methods for backward-compatability. These methods materialize</span>
<span class="sd">    the entire result set (loading all pages), and should only be used if the</span>
<span class="sd">    total result size is understood. Warnings are emitted when paged results</span>
<span class="sd">    are materialized in this fashion.</span>

<span class="sd">    You can treat this as a normal iterator over rows::</span>

<span class="sd">        &gt;&gt;&gt; from cassandra.query import SimpleStatement</span>
<span class="sd">        &gt;&gt;&gt; statement = SimpleStatement(&quot;SELECT * FROM users&quot;, fetch_size=10)</span>
<span class="sd">        &gt;&gt;&gt; for user_row in session.execute(statement):</span>
<span class="sd">        ...     process_user(user_row)</span>

<span class="sd">    Whenever there are no more rows in the current page, the next page will</span>
<span class="sd">    be fetched transparently.  However, note that it *is* possible for</span>
<span class="sd">    an :class:`Exception` to be raised while fetching the next page, just</span>
<span class="sd">    like you might see on a normal call to ``session.execute()``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response_future</span><span class="p">,</span> <span class="n">initial_response</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span> <span class="o">=</span> <span class="n">response_future</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span> <span class="o">=</span> <span class="n">response_future</span><span class="o">.</span><span class="n">_col_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_types</span> <span class="o">=</span> <span class="n">response_future</span><span class="o">.</span><span class="n">_col_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_rows</span><span class="p">(</span><span class="n">initial_response</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_page_iter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_list_mode</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_more_pages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if the last response indicated more pages; False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">has_more_pages</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of current page rows. May be empty if the result was empty,</span>
<span class="sd">        or this is the last page.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span> <span class="ow">or</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_mode</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_page_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_page_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">has_more_pages</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_mode</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">raise</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fetch_next_page</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_page_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_page_iter</span><span class="p">)</span>

    <span class="fm">__next__</span> <span class="o">=</span> <span class="nb">next</span>

<div class="viewcode-block" id="ResultSet.fetch_next_page"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResultSet.fetch_next_page">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_next_page</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manually, synchronously fetch the next page. Supplied for manually retrieving pages</span>
<span class="sd">        and inspecting :meth:`~.current_page`. It is not necessary to call this when iterating</span>
<span class="sd">        through results; paging happens implicitly in iteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">has_more_pages</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">start_fetching_next_page</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_current_rows</span>  <span class="c1"># ResultSet has already _set_current_rows to the appropriate form</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span> <span class="o">=</span> <span class="p">[]</span></div>

    <span class="k">def</span> <span class="nf">_set_current_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="k">if</span> <span class="n">result</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># can&#39;t check directly for generator types because cython generators are different</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="k">if</span> <span class="n">result</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_fetch_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_page_iter</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_enter_list_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list_mode</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_page_iter</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot use </span><span class="si">%s</span><span class="s2"> when results have been iterated.&quot;</span> <span class="o">%</span> <span class="n">operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">has_more_pages</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Using </span><span class="si">%s</span><span class="s2"> on paged results causes entire result set to be materialized.&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fetch_all</span><span class="p">()</span>  <span class="c1"># done regardless of paging status in case the row factory produces a generator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_list_mode</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enter_list_mode</span><span class="p">(</span><span class="s2">&quot;equality operator&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enter_list_mode</span><span class="p">(</span><span class="s2">&quot;index operator&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_rows</span><span class="p">)</span>

    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

<div class="viewcode-block" id="ResultSet.get_query_trace"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResultSet.get_query_trace">[docs]</a>    <span class="k">def</span> <span class="nf">get_query_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_wait_sec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the last query trace from the associated future.</span>
<span class="sd">        See :meth:`.ResponseFuture.get_query_trace` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">get_query_trace</span><span class="p">(</span><span class="n">max_wait_sec</span><span class="p">)</span></div>

<div class="viewcode-block" id="ResultSet.get_all_query_traces"><a class="viewcode-back" href="../../api/cassandra/cluster.html#cassandra.cluster.ResultSet.get_all_query_traces">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_query_traces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_wait_sec_per</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets all query traces from the associated future.</span>
<span class="sd">        See :meth:`.ResponseFuture.get_all_query_traces` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">get_all_query_traces</span><span class="p">(</span><span class="n">max_wait_sec_per</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">was_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For LWT results, returns whether the transaction was applied.</span>

<span class="sd">        Result is indeterminate if called on a result that was not an LWT request.</span>

<span class="sd">        Only valid when one of tne of the internal row factories is in use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">row_factory</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">named_tuple_factory</span><span class="p">,</span> <span class="n">dict_factory</span><span class="p">,</span> <span class="n">tuple_factory</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot determine LWT result with row factory </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">row_factsory</span><span class="p">,))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_rows</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;LWT result should have exactly one row. This has </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_rows</span><span class="p">)))</span>

        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;[applied]&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">paging_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Server paging state of the query. Can be `None` if the query was not paged.</span>

<span class="sd">        The driver treats paging state as opaque, but it may contain primary key data, so applications may want to</span>
<span class="sd">        avoid sending this to untrusted parties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">response_future</span><span class="o">.</span><span class="n">_paging_state</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Cassandra Driver 3.11.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../cassandra.html" >cassandra</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013-2017 DataStax.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>